---
title: Compiling Prolog
---

> **Work in progress**: This article is gonna be lo-o-ong. I initially thought about splitting it into separate posts, but instead I decided to write and post this one section by section. 

Since we last saw each other, I've outfitted [my miniature Prolog interpreter](/posts/2019-12-01-write-you-a-prolog.html) with [a virtual machine and an x64 code generator](https://github.com/benjamin-hodgson/Amateurlog/tree/master/Machine). I wanted to document my work in guide form.

Why write another introductory build-a-compiler guide? There are lots of examples out there of how to make a compiler, but they tend to skew towards simple languages with a straightforward execution model (imperative languages, or simple functional ones). Prolog's core is a simple language, but it features an unusual execution model which doesn't map straightforwardly into low-level code, so I figured it'd make an interesting example.

This article leads on from [my earlier series of four posts](/posts/2019-12-01-write-you-a-prolog.html) about modelling Prolog in C#, so I'd recommend reading those before you read this so as not to get too lost. In order to get the code working, though, you'll only need [the AST](https://github.com/benjamin-hodgson/Amateurlog/blob/master/Syntax.cs) from [the first post](/posts/2019-12-01-write-you-a-prolog.html) and [the parser](https://github.com/benjamin-hodgson/Amateurlog/blob/master/Parser.cs) from [the second one](/posts/2019-12-08-parsing-prolog-with-pidgin.html).

I did a lot of reading while working on this code, especially [_Warren's Abstract Machine: A Tutorial Reconstruction_](http://wambook.sourceforge.net/). I'll be covering similar topics in a similar order to that book, but my design is a bit different than Warren's --- just because I was trying to write code which fits the way I think. (I'm certainly not claiming my system is better --- the WAM is a mature design used in production-quality Prolog systems!)


Anatomy of a Heap Object
------------------------

A compiler's job, to a large extent, is to flatten things. The code you type into your editor often has a nested structure, with curly braces and parentheses and whatnot, because that's a convenient way for humans to think. But it's not convenient for a CPU! Your CPU consumes a linear sequence of instructions and manipulates memory through a big flat address space. When you work with a graph of objects with references to each other, the compiler has to figure out a way to represent that graph of objects in that flat address space.

So we have access to a big flat slab of bytes, and we need to think of a way to represent nested Prolog terms like `foo(bar(X), Y, baz(X), quux())`.

Let's start simple. How would we represent a functor term with no arguments such as `quux()`? We could store the name of the functor on the heap, but for efficiency's sake let's instead give it an ID --- say, `123`. (These IDs will be generated by the compiler and mapped to names in a static data structure. More on that later.)

```
address: 0     1
         -------
         | 123 |
         -------
           ID
```

Simple enough! How about a term with arguments like `foo(bar(), quux())`?

