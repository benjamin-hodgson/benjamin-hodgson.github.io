<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>benjamin.pizza - Parallelising Source Positions</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2.1.1/out/water.min.css" integrity="sha256-QST90Wzz4PEr5KlclQaOCsjc00FTyf86Wrj41oqZB4w=" crossorigin="anonymous" />
        <link rel="stylesheet" type="text/css" href="../all.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>
    </head>
    <body>
        <header id="header">
            <nav id="navigation">
                <ul>
                    <li id="logo"><a href="../">benjamin.pizza</a></li>
                    <li><a href="../contact.html">Contact</a></li>
                    <li><a href="../archive.html">Archive</a></li>
                    <li><a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a></li>
                </ul>
            </header>
        </header>

        <article>
            <header>
                <h1>Parallelising Source Positions</h1>
                
                
                    <p><time datetime="2022-07-16">July 16, 2022</time></p>
                
            </header>

            
<p>My parsing library <a href="https://github.com/benjamin-hodgson/Pidgin">Pidgin</a> has some infrastructure to track positions in a textual input file, for the purposes of error reporting. The library’s written in C#, but for today let’s work in Haskell.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SourcePos</span> <span class="ot">=</span> <span class="dt">SourcePos</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    line ::</span> <span class="dt">Natural</span>,</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    col ::</span> <span class="dt">Natural</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="ot">startOfFile ::</span> <span class="dt">SourcePos</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>startOfFile <span class="ot">=</span> <span class="dt">SourcePos</span> <span class="dv">1</span> <span class="dv">1</span></span></code></pre></div><p>The parser keeps track of the current <code>SourcePos</code> by looping over the characters in the input file and calling a method called <code>calculateSourcePos</code>. <code>calculateSourcePos</code>’s job is to update the current <code>SourcePos</code> for a single character.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>newSourcePos <span class="ot">=</span> foldl' calculateSourcePos oldSourcePos inputText</span></code></pre></div><p>You can supply your own <code>calculateSourcePos</code> implementation, but the default one looks roughly like this:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">calculateSourcePos ::</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">SourcePos</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>calculateSourcePos sp <span class="ch">'\n'</span> <span class="ot">=</span> <span class="dt">SourcePos</span> {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    line <span class="ot">=</span> line sp <span class="op">+</span> <span class="dv">1</span>,  <span class="co">-- increment the line count</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    col <span class="ot">=</span> <span class="dv">1</span>  <span class="co">-- and reset the column count</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>calculateSourcePos sp _ <span class="ot">=</span> sp { col <span class="ot">=</span> col sp <span class="op">+</span> <span class="dv">1</span> }</span></code></pre></div><p>When the parser encounters a new line, the column counter is reset back to 1.</p>
<p>The signature of <code>calculateSourcePos</code> poses a performance problem: it takes the previous <code>SourcePos</code> as an argument. Each iteration of the loop depends on the result of the previous iteration. This <em>data dependency</em> means the loop can’t be parallelised — you have to wait for each iteration of the loop to finish before you can start the next one.</p>
<p>This article is about redesigning <code>SourcePos</code> to be more parallelisable.</p>
<h2 id="monoids-are-embarrassingly-parallel"><a href="#monoids-are-embarrassingly-parallel">Monoids are Embarrassingly Parallel

</a></h2>
<p><em>Monoid</em> is the high-falutin’ mathsy name for a certain variety of composable objects. Composability is very important in programming, and consequently monoids show up all over the place. There are plenty of introductions to monoids out there (mostly by <a href="https://blog.ploeh.dk/2017/10/06/monoids/">better</a> <a href="https://www.youtube.com/watch?v=-mnA8_DWfik">teachers</a> than me), so I’ll keep it brief.</p>
<p>For an object to be a monoid you need two things:</p>
<ol>
<li>
<p>An operator <code>&lt;&gt;</code> which combines two values of your type into a bigger value.</p>
<ul>
<li>It shouldn’t matter how you nest a sequence of <code>&lt;&gt;</code> operations: <code>(x &lt;&gt; y) &lt;&gt; z == x &lt;&gt; (y &lt;&gt; z)</code>.
</li>
</ul>
</li>
<li>
<p>A <code>mempty</code> value, representing some notion of “zero”.</p>
<ul>
<li>Combining <code>mempty</code> with another value should leave that value unchanged: <code>mempty &lt;&gt; x == x == x &lt;&gt; mempty</code>.
</li>
</ul>
</li>
</ol>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty ::</span> m</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;&gt;) ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre></div><p>The rule about nesting <code>&lt;&gt;</code> is what makes monoids good for parallelism. Suppose you have a big array of monoidal values, and you want to combine them all into a single value using <code>&lt;&gt;</code>. It doesn’t matter what order you perform the additions in, so you can safely divide your array into chunks, sum up each chunk in parallel, and then combine the results. (This is the basic idea behind MapReduce.)</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fu">mconcat</span><span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Vector</span> m <span class="ot">-&gt;</span> m</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="fu">mconcat</span> <span class="ot">=</span> Vector.foldr (<span class="op">&lt;&gt;</span>) <span class="fu">mempty</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="co">-- performs the same computation but in parallel</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="ot">pmconcat ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Vector</span> m <span class="ot">-&gt;</span> m</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>pmconcat <span class="ot">=</span> List.foldr (<span class="op">&lt;&gt;</span>) <span class="fu">mempty</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> parMap <span class="fu">mconcat</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> chunksOf <span class="dv">1024</span></span></code></pre></div><p>To put it another way, monoids don’t suffer from the data dependency which made <code>calculateSourcePos</code> hard to parallelise. The challenge, then, is to come up with a way to make <code>SourcePos</code> into a monoid.</p>
<h2 id="deltas"><a href="#deltas">Deltas

</a></h2>
<p>If you go hiking, you might bring with you a list of directions on a piece of paper. Directions are monoidal: if you have directions from your house to the beach, and from the beach to the pub, you can follow those directions sequentially to get from your house to the pub. (I’ll tolerate hiking as long as the destination is a pub.)</p>
<p>Directions are relative, not absolute. The directions on your paper might tell you how to get from your house to the pub, but if you start somewhere other than your house you can still follow the directions — you just have to hope you end up in a different pub.</p>
<p>So by analogy, let’s stop worrying about absolute locations in a source file and instead think about offsets relative to an arbitrary location.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SourcePosDelta</span> <span class="ot">=</span> <span class="dt">SourcePosDelta</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    lines ::</span> <span class="dt">Natural</span>,</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    cols ::</span> <span class="dt">Natural</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><p>You can add a relative <code>SourcePosDelta</code> to an absolute <code>SourcePos</code> to get a new absolute <code>SourcePos</code>. This is analogous to setting off on a hike from a given starting location.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> <span class="dt">SourcePosDelta</span> <span class="ot">-&gt;</span> <span class="dt">SourcePos</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>add sp delta <span class="ot">=</span> <span class="dt">SourcePos</span> {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    line <span class="ot">=</span> line sp <span class="op">+</span> <span class="fu">lines</span> delta,</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    col <span class="ot">=</span> (<span class="kw">if</span> <span class="fu">lines</span> delta <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> col sp <span class="kw">else</span> <span class="dv">0</span>) <span class="op">+</span> cols delta</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><p>When the delta spans multiple lines, we discard <code>col sp</code> and only take <code>cols delta</code>. This reflects the behaviour of <code>computeSourcePos</code>, which resets the column counter when a new line is encountered. The asymmetry is interesting, though; the <code>line</code> calculation depends only on the two <code>lines</code> fields, but the <code>col</code> field has some interference from the <code>lines</code>.</p>
<p>Likewise, you can find the difference between two <code>SourcePos</code>es to get the path that would take you from one to the other:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fu">subtract</span><span class="ot"> ::</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> <span class="dt">SourcePosDelta</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="fu">subtract</span> start end <span class="ot">=</span> <span class="dt">SourcePosDelta</span> {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines</span> <span class="ot">=</span> line end <span class="op">-</span> line start,</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    cols <span class="ot">=</span> col end <span class="op">-</span> (<span class="kw">if</span> line end <span class="op">==</span> line start <span class="kw">then</span> col start <span class="kw">else</span> <span class="dv">0</span>)</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><p>From here we can see how to add a pair of <code>SourcePosDelta</code>s (and write the <code>Monoid</code> instance). In fact, the code is more or less identical to <code>add</code>:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">SourcePosDelta</span> <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">SourcePosDelta</span> <span class="dv">0</span> <span class="dv">0</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    delta1 <span class="op">&lt;&gt;</span> delta2 <span class="ot">=</span> <span class="dt">SourcePosDelta</span> {</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">lines</span> <span class="ot">=</span> <span class="fu">lines</span> delta1 <span class="op">+</span> <span class="fu">lines</span> delta2,</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>        cols <span class="ot">=</span> (<span class="kw">if</span> <span class="fu">lines</span> delta2 <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> cols delta1 <span class="kw">else</span> <span class="dv">0</span>) <span class="op">+</span> cols delta2</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div><p>I’ll leave it up to you to convince yourself that this definition satisfies the monoid laws.</p>
<p>Each character in the input file corresponds to a small <code>SourcePosDelta</code>: <code>'\n'</code> corresponds to <code>SourcePosDelta 1 0</code> and each other character corresponds to <code>SourcePosDelta 0 1</code>. The parser can map each character to a <code>SourcePosDelta</code>, add up the monoidal deltas (possibly in parallel), and then add the result to the <code>SourcePos</code> corresponding to the start of the <code>inputText</code>.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>calculateSourcePosDelta inputText <span class="ot">=</span> pmconcat <span class="op">$</span> parMap toDelta inputText</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        toDelta <span class="ch">'\n'</span> <span class="ot">=</span> <span class="dt">SourcePosDelta</span> <span class="dv">1</span> <span class="dv">0</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        toDelta _ <span class="ot">=</span> <span class="dt">SourcePosDelta</span> <span class="dv">0</span> <span class="dv">1</span></span></code></pre></div><h2 id="hardware-parallelism"><a href="#hardware-parallelism">Hardware Parallelism

</a></h2>
<p><a href="https://github.com/benjamin-hodgson/Pidgin/blob/sourceposdelta/Pidgin.Bench/SourcePosDeltaBench.cs">I tested some implementations of <code>&lt;&gt;</code> (in C#)</a> which made use of modern CPUs’ support for <em>hardware parallelism</em> (also known as SIMD, for Single Instruction Multiple Data). Recent versions of .NET come bundled with opt-in SIMD support, to be found in <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics?view=net-6.0">the <code>System.Numerics</code> namespace</a>.</p>
<p>CPUs with SIMD have extra-wide registers (like, 256 bits) divided into <em>lanes</em>. You can stuff four 64-bit integers (or eight 32-bit ones) into a single register, and the CPU supports special instructions to perform the same operation on each of those four integers at once — so (for example) you can add four sets of two integers with a single instruction. Each SIMD operation is a little bit slower than its corresponding single-target instruction, but since they operate on four times the amount of data you can often get reasonable speedups when you’re processing lots of data.</p>
<p><a href="https://github.com/benjamin-hodgson/Pidgin/blob/539ecf23b8ebf0f601a48ade7576343671ef075c/Pidgin.Bench/SourcePosDeltaBench.cs#L278">My fastest attempt</a> involved packing <code>SourcePosDelta</code>’s two integers into <a href="https://github.com/benjamin-hodgson/Pidgin/blob/539ecf23b8ebf0f601a48ade7576343671ef075c/Pidgin.Bench/SourcePosDeltaBench.cs#L320">a single 64-bit integer</a> and doing some <a href="https://github.com/benjamin-hodgson/Pidgin/blob/539ecf23b8ebf0f601a48ade7576343671ef075c/Pidgin.Bench/SourcePosDeltaBench.cs#L334">bit manipulation</a> to implement <code>&lt;&gt;</code>’s “annihilation” semantics. Then I divided the input array into four chunks — one per lane — and ran the bit manipulation algorithm on each lane. Since it’s best to load contiguous data into a SIMD register’s lanes, I had to <a href="https://github.com/benjamin-hodgson/Pidgin/blob/539ecf23b8ebf0f601a48ade7576343671ef075c/Pidgin.Bench/SourcePosDeltaBench.cs#L51">rearrange the input array</a> to line the chunks up with their SIMD lanes.</p>
<p>I decided against putting the SIMD code into the library, because in practice the number of <code>SourcePosDelta</code>s which need summing is often not very large. In any case, the SIMD code offered comparable performance to a much simpler algorithm: loop backwards until you find the last newline in a chunk of text, then ignore any non-newline characters to the left of it.</p>
<h2 id="spans-and-shifts"><a href="#spans-and-shifts">Spans and Shifts

</a></h2>
<p>Here’s another cool thing you can do with <code>SourcePosDelta</code>.</p>
<p>In general, each node in a parse tree corresponds to a certain <em>span</em> of the input document: the section of the input text containing a given syntactic construct.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Span</span> <span class="ot">=</span> <span class="dt">Span</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    start ::</span> <span class="dt">SourcePos</span>,</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    width ::</span> <span class="dt">SourcePosDelta</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="ot">end ::</span> <span class="dt">Span</span> <span class="ot">-&gt;</span> <span class="dt">SourcePos</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>end <span class="fu">span</span> <span class="ot">=</span> add (start <span class="fu">span</span>) (width <span class="fu">span</span>)</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a><span class="ot">containsPos ::</span> <span class="dt">Span</span> <span class="ot">-&gt;</span> <span class="dt">SourcePos</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span> <span class="ot">`containsPos`</span> pos <span class="ot">=</span> pos <span class="op">&gt;=</span> start <span class="fu">span</span> <span class="op">&amp;&amp;</span> pos <span class="op">&lt;=</span> end <span class="fu">span</span></span></code></pre></div><p>It’s common in compilers to keep track of these spans in order to report error messages. For example, you might want to colour a piece of code red in an IDE if it contains an error.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Node</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    span ::</span> <span class="dt">Span</span>,</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    data ::</span> <span class="dt">Expr</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Lit</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Node</span> <span class="dt">Node</span></span></code></pre></div><p>In an interactive IDE, you have a programmer typing code; the IDE’s parser needs to respond in real time to each keystroke. So, for performance’s sake, you only want to re-parse the fragment of code that the user is currently typing, and reuse the rest of the document’s parse tree from the last time you parsed it.</p>
<p>But when the user types characters into the middle of a document, all of the constructs after it get moved right and down. So you need to <code>shift</code> the parse tree over by the amount that the user typed.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">shift ::</span> <span class="dt">SourcePosDelta</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>shift d (<span class="dt">Node</span> <span class="fu">span</span> <span class="kw">data</span>) <span class="ot">=</span> <span class="dt">Node</span> (shiftSpan d <span class="fu">span</span>) (shiftData <span class="kw">data</span>)</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        shiftData l<span class="op">@</span>(<span class="dt">Lit</span> _) <span class="ot">=</span> l</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        shiftData (<span class="dt">Add</span> l r) <span class="ot">=</span> <span class="dt">Add</span> (shift d l) (shift d r)</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="ot">shiftSpan ::</span> <span class="dt">SourcePosDelta</span> <span class="ot">-&gt;</span> <span class="dt">Span</span> <span class="ot">-&gt;</span> <span class="dt">Span</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>shiftSpan d (<span class="dt">Span</span> start width) <span class="ot">=</span> <span class="dt">Span</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- we need to add `d` on the _left_ of `start`,</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- so we can't use `add start d`. Instead,</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- round-trip via `SourcePosDelta`.</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    (add startOfFile (d <span class="op">&lt;&gt;</span> <span class="fu">subtract</span> startOfFile start))</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>    width</span></code></pre></div><p><code>shift</code> rebuilds the entire tree! That’s asymptotically as bad as re-parsing the entire file — clearly not something we want to do on every keystroke. Instead, let’s annotate the tree with the amount by which it’s been shifted. This lets us shift a whole subtree at once without mutating it.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Node</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    shiftedBy ::</span> <span class="dt">SourcePosDelta</span>,</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    originalSpan ::</span> <span class="dt">Span</span>,</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="ot">    expr ::</span> <span class="dt">Expr</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Span</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="fu">span</span> (<span class="dt">Node</span> shift <span class="fu">span</span> _) <span class="ot">=</span> shiftSpan shift <span class="fu">span</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="ot">shift ::</span> <span class="dt">SourcePosDelta</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>shift delta node <span class="ot">=</span> node { shiftedBy <span class="ot">=</span> delta <span class="op">&lt;&gt;</span> shiftedBy node }</span></code></pre></div><p><code>shift</code> is very fast now; it only rebuilds a single node. When the compiler traverses the parse tree, it simply needs to keep track of the current shift amount and apply that shift to any locations reported in error messages.</p>
<p>For completeness, here is some code to apply an edit to a parse tree. <code>edit</code> searches the parse tree to find the node where the edit occurred, replaces that node, and <code>shifts</code> everything that was textually to the right of that node.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">editSpan ::</span> <span class="dt">Span</span>  <span class="co">-- ^ The location and amount the user typed</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Span</span>  <span class="co">-- ^ The original span</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Span</span>  <span class="co">-- ^ The span with the edit applied</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>editSpan edit <span class="fu">span</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">not</span> (<span class="fu">span</span> <span class="ot">`containsPos`</span> start edit) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Span</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>        (start <span class="fu">span</span>)</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- insert `edit`'s `SourcePosDelta` into `span`'s</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">subtract</span> (start <span class="fu">span</span>) (start edit)</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;&gt;</span> width edit</span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;&gt;</span> <span class="fu">subtract</span> (end <span class="fu">span</span>) (end edit))</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a><span class="ot">edit ::</span> <span class="dt">Span</span>  <span class="co">-- ^ The location and amount the user typed</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Expr</span>  <span class="co">-- ^ The replacement parse tree</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Node</span>  <span class="co">-- ^ The original parse tree</span></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Node</span>  <span class="co">-- ^ The edited parse tree</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>edit s replacement node <span class="ot">=</span> <span class="dt">Node</span></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- this `fromJust` is ok assuming that the edit was inside `span node`</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>    (fromJust <span class="op">$</span> editSpan s (<span class="fu">span</span> node))</span>
<span id="21"><a href="#21" aria-hidden="true" tabindex="-1"></a>    (editExpr (expr node))</span>
<span id="22"><a href="#22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="23"><a href="#23" aria-hidden="true" tabindex="-1"></a>        editExpr (<span class="dt">Lit</span> _) <span class="ot">=</span> replacement</span>
<span id="24"><a href="#24" aria-hidden="true" tabindex="-1"></a>        editExpr (<span class="dt">Add</span> l r)</span>
<span id="25"><a href="#25" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">span</span> l <span class="ot">`containsPos`</span> start s <span class="ot">=</span></span>
<span id="26"><a href="#26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Add</span> (edit s replacement l) (shift (width s) r)</span>
<span id="27"><a href="#27" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">span</span> r <span class="ot">`containsPos`</span> start s <span class="ot">=</span></span>
<span id="28"><a href="#28" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Add</span> l (edit s replacement r)</span>
<span id="29"><a href="#29" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> replacement</span></code></pre></div><p>This code is linear in the <em>depth</em> of the tree, which is usually shallow (typically dozens of nodes deep, rather than hundreds or thousands). You could do even better asymptotically by storing the parse tree in a <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)">zipper</a> focused on the node the user is currently editing, and lazily apply shifts as the zipper moves around.</p>
<h2 id="monoid-actions"><a href="#monoid-actions">Monoid Actions

</a></h2>
<p>Let’s look a little closer at the formalism underlying <code>SourcePosDelta</code>.</p>
<p>This idea of building up a monoid and then using it to transform some other value is formalised using the notion of <em>actions</em> (also known as <em>modules</em>). A monoidal object is said to be a <em>monoid action</em> on some other object <code>a</code> if it can be used to transform <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;Action a m&quot; means &quot;m acts on a&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Action</span> a m <span class="kw">where</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">    act ::</span> m <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div><p>I always thought <em>action monoid</em> would make a better name for this concept than <em>monoid action</em>. The monoidal value <code>m</code> represents an action to be carried out on some other object <code>a</code>.</p>
<p>To be a well-behaved monoid action, the <code>act</code> method should respect the monoidal nature of the action:</p>
<ol>
<li>
<p><code>mempty</code> should be a no-op action: <code>act mempty == id</code>.</p>
</li>
<li>
<p>Building a monoidal value with <code>&lt;&gt;</code> and then acting with it should be the same as acting with the individual pieces of the monoid: <code>(m &lt;&gt; n) `act` x == m `act` (n `act` x)</code>.</p>
<ul>
<li>
<p>This rule defines a “left” monoid action. It turns out that <code>SourcePosDelta</code> is actually a “right” monoid action, for which this rule is flipped: <code>(m &lt;&gt; n) `act` x == n `act` (m `act` x)</code>.</p>
</li>
<li>
<p>In fact, let’s separate the ideas of “left” and “right” actions. I find that the composition law for right actions makes more sense when the arguments are the other way around.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">LAction</span> a m <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">    lact ::</span> m <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">RAction</span> a m <span class="kw">where</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="ot">    ract ::</span> a <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> a</span></code></pre></div><p>So now <code>RAction</code>’s composition law reads <code>x `ract` (m &lt;&gt; n) == (x `ract` m) `ract` n</code>.</p>
</li>
</ul>
</li>
</ol>
<p>Basically, these laws assert that you can build actions with <code>&lt;&gt;</code> and it’ll behave in the way you expect.</p>
<p>Here are a couple of examples to help you think about monoid actions.</p>
<ol>
<li>
<p>Yes, <code>SourcePosDelta</code> is a monoid action on <code>SourcePos</code>. Adding a <code>SourcePosDelta</code> to a <code>SourcePos</code> gives you a new <code>SourcePos</code> representing somewhere later in the file — a <code>SourcePosDelta</code> represents the action of moving to a later location. You can convince yourself that the definition of <code>ract</code> does indeed satisfy the laws I outlined above:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">RAction</span> <span class="dt">SourcePos</span> <span class="dt">SourcePosDelta</span> <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    ract sp delta <span class="ot">=</span> <span class="dt">SourcePos</span> {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        line <span class="ot">=</span> line sp <span class="op">+</span> <span class="fu">lines</span> delta,</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        col <span class="ot">=</span> (<span class="kw">if</span> <span class="fu">lines</span> delta <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> col sp <span class="kw">else</span> <span class="dv">0</span>) <span class="op">+</span> cols delta</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div></li>
<li>
<p>I first learned about monoid actions (well, group actions) during a crystallography course at university. Crystallographers are very concerned with symmetry, because crystals are repeating structures which look the same in every direction. Crystals can be categorised by the collection of rotations, reflections and translations (the <em>space group</em>) under which the crystal looks the same. You monoidally build up a sequence of spatial transformations, and then use those transformations to act on a crystal.</p>
<p>A more familiar way of phrasing the same example: When you go hiking with written directions, you can think of the directions as acting on your current location. When you follow a direction such as “walk 200 metres”, you update your location accordingly.</p>
</li>
<li>
<p>Any monoid can always be thought of as acting upon itself, simply by defining <code>act = (&lt;&gt;)</code>.</p>
</li>
</ol>
<h2 id="actions-all-the-way-down"><a href="#actions-all-the-way-down">Actions All the Way Down

</a></h2>
<p>It turns out monoid actions can also explain the strange asymmetry in <code>SourcePosDelta</code>’s <code>(&lt;&gt;)</code> method. When computing <code>delta1 &lt;&gt; delta2</code>, we can think of <code>delta2</code>’s <code>lines</code> as acting on <code>delta1</code>’s <code>cols</code>.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Lines</span> <span class="ot">=</span> <span class="dt">Lines</span> <span class="dt">Natural</span> <span class="kw">deriving</span> <span class="dt">Monoid</span> via (<span class="dt">Sum</span> <span class="dt">Natural</span>)</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cols</span> <span class="ot">=</span> <span class="dt">Cols</span> <span class="dt">Natural</span> <span class="kw">deriving</span> <span class="dt">Monoid</span> via (<span class="dt">Sum</span> <span class="dt">Natural</span>)</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">RAction</span> <span class="dt">Cols</span> <span class="dt">Lines</span> <span class="kw">where</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    ract c (<span class="dt">Lines</span> <span class="dv">0</span>) <span class="ot">=</span> c</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    ract _ _ <span class="ot">=</span> <span class="dt">Cols</span> <span class="dv">0</span></span></code></pre></div><p><code>Lines</code>’s action on <code>Cols</code> is to erase the <code>Cols</code> altogether when the number of <code>Lines</code> is not zero. It’s a weirdly degenerate monoid action, but it’s an action nonetheless. (It seems like <code>Lines</code> basically represents an <a href="https://en.wikipedia.org/wiki/Annihilator_(ring_theory)">annihilator</a> for <code>Cols</code>.)</p>
<p>With <code>Lines</code>’s action on <code>Cols</code> in hand, <code>SourcePosDelta</code>’s <code>Monoid</code> instance can be explained as an instance of a (right) <em>semi-direct product</em>. A semi-direct product is like a regular product type <code>(a, b)</code>, except its <code>Monoid</code> instance allows for one of the fields to interfere with the other by acting on it:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RSemiDirect</span> a b <span class="ot">=</span> <span class="dt">RSD</span> a b</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> b, <span class="dt">RAction</span> a b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">RSemiDirect</span> a b) <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">RSD</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">RSD</span> x1 y1) <span class="op">&lt;&gt;</span> (<span class="dt">RSD</span> x2 y2) <span class="ot">=</span> <span class="dt">RSD</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>        (ract x1 y2 <span class="op">&lt;&gt;</span> x2)</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        (y1 <span class="op">&lt;&gt;</span> y2)</span></code></pre></div><p><code>RSemiDirect a b</code> is a monoid when <code>b</code>’s action on <code>a</code> respects <code>a</code>’s monoidal structure:</p>
<ol>
<li>
<p>Acting on an empty monoid produces another empty monoid: <code>ract mempty x == mempty</code>.</p>
</li>
<li>
<p><code>b</code>’s monoidal structure distributes over <code>a</code>’s: <code>ract (x &lt;&gt; y) z == ract x z &lt;&gt; ract y z</code>.</p>
</li>
</ol>
<p>I won’t prove it here, but these do hold for <code>Lines</code>’s action on <code>Cols</code>. So we have a clean explanation for <code>SourcePosDelta</code>’s asymmetric monoidal structure in terms of the semi-direct product:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SourcePosDelta</span> <span class="ot">=</span> <span class="dt">RSemiDirect</span> <span class="dt">Cols</span> <span class="dt">Lines</span></span></code></pre></div><p>I first read about semi-direct products a few years ago in <a href="http://ozark.hendrix.edu/~yorgey/pub/twisted.pdf">the “twisted functors” paper</a>. They use semi-direct products to manage pointer arithmetic while writing to buffers — monoidally building up an offset and using it to act on a base pointer. They also give a couple of other examples.</p>


        </article>

        <footer id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
