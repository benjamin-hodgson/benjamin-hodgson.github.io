<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>benjamin.pizza - Zooming In on Field Accessors</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>

        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../" id="logo"><pre class="title">benjamin.pizza</pre></a>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
                <a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a>
            </div>
        </div>

        <div id="content">
            <header>
                <h1>Zooming In on Field Accessors</h1>
                
            </header>

            <div class="info">
    Posted on December  6, 2018
    
</div>

<p>It‚Äôs common in functional languages ‚Äî and increasingly in hybrid languages like C# ‚Äî to work with complex systems of immutable datatypes. For a contrived example, suppose you‚Äôre working on a billing application:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> Order</a>
<a class="sourceLine" id="cb1-2" title="2">{</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">public</span> Customer Customer { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">public</span> ImmutableList&lt;Product&gt; Products { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-5" title="5">}</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">class</span> Customer</a>
<a class="sourceLine" id="cb1-7" title="7">{</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">public</span> <span class="dt">string</span> Name { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">public</span> Address Address { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-10" title="10">}</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">class</span> Address</a>
<a class="sourceLine" id="cb1-12" title="12">{</a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="kw">public</span> <span class="dt">string</span> Line1 { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="kw">public</span> <span class="dt">string</span> Line2 { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="kw">public</span> <span class="dt">string</span> Postcode { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-16" title="16">}</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">class</span> Product</a>
<a class="sourceLine" id="cb1-18" title="18">{</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="kw">public</span> <span class="dt">string</span> Title { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="kw">public</span> <span class="dt">decimal</span> Price { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-21" title="21">}</a></code></pre></div>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/model.jpg" width="900" /></p>
<p>(I‚Äôve omitted the constructors; you can imagine your own.) These objects are immutable, meaning you can‚Äôt modify them directly. The way to update an immutable object is to make a copy of that object with the relevant properties changed. This turns out to be surprisingly tedious when you‚Äôre working inside a deeply nested structure:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb2-1" title="1">Order <span class="fu">UpdatePostcode</span>(Order order<span class="co">/*üë®üèª‚Äç‚öñÔ∏è*/</span>, <span class="dt">string</span> newPostcode)</a>
<a class="sourceLine" id="cb2-2" title="2">    =&gt; <span class="kw">new</span> <span class="fu">Order</span>(</a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="kw">new</span> <span class="fu">Customer</span>(</a>
<a class="sourceLine" id="cb2-4" title="4">            order.<span class="fu">Customer</span>.<span class="fu">Name</span>,</a>
<a class="sourceLine" id="cb2-5" title="5">            <span class="kw">new</span> <span class="fu">Address</span>(</a>
<a class="sourceLine" id="cb2-6" title="6">                order.<span class="fu">Customer</span>.<span class="fu">Address</span>.<span class="fu">Line1</span>,</a>
<a class="sourceLine" id="cb2-7" title="7">                order.<span class="fu">Customer</span>.<span class="fu">Address</span>.<span class="fu">Line2</span>,</a>
<a class="sourceLine" id="cb2-8" title="8">                newPostcode</a>
<a class="sourceLine" id="cb2-9" title="9">            )</a>
<a class="sourceLine" id="cb2-10" title="10">        ),</a>
<a class="sourceLine" id="cb2-11" title="11">        order.<span class="fu">Products</span></a>
<a class="sourceLine" id="cb2-12" title="12">    );</a></code></pre></div>
<p>F#‚Äôs <code>with</code>-syntax helps a little, but not a lot. You still have to write each name multiple times.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> updatePostcode(order : Order, newPostcode : <span class="dt">string</span>) : Order = {</a>
<a class="sourceLine" id="cb3-2" title="2">  order <span class="kw">with</span> customer = {</a>
<a class="sourceLine" id="cb3-3" title="3">    order.customer <span class="kw">with</span> address = {</a>
<a class="sourceLine" id="cb3-4" title="4">      order.customer.address <span class="kw">with</span> postcode = newPostcode</a>
<a class="sourceLine" id="cb3-5" title="5">    }</a>
<a class="sourceLine" id="cb3-6" title="6">  }</a>
<a class="sourceLine" id="cb3-7" title="7">}</a></code></pre></div>
<p>This pain is caused by immutability. In an imperative setting you can say <code>order.Customer.Address.Postcode = newPostcode;</code>, although of course mutable data is less reliable and harder to work with overall. Rather than give up on immutability, functional programmers have invented a remarkable family of composable tools called <em>optics</em> for poking around inside complex datatypes. Optics are a way of describing ‚Äúpaths‚Äù through structures: you can compose paths together, and read and write the values at the end of those paths. I‚Äôm here today to demonstrate that C#8‚Äôs upcoming <a href="https://github.com/dotnet/csharplang/issues/52"><em>default interface methods</em></a> are great at modelling optics.</p>
<p>Let‚Äôs start with <em>lenses</em>, the family member that gave the family its name.</p>
<h2 id="lenses">Lenses</h2>
<p>A <em>lens</em> is a first-class property for an immutable object. It‚Äôs an object with a pair of methods, a <em>getter</em> which retrives the value of a property and a <em>setter</em> which updates it. Remember, we‚Äôre working with immutable data, so the setter returns a new copy of the object.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb4-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb4-5" title="5">}</a></code></pre></div>
<p>For example, here‚Äôs a lens which focuses on a <code>Customer</code>‚Äôs <code>Address</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> AddressL : ILens&lt;Customer, Address&gt;</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">public</span> Address <span class="fu">Get</span>(Customer c) =&gt; c.<span class="fu">Address</span>;</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">public</span> Customer <span class="fu">Set</span>(Customer c, Address a) =&gt; <span class="kw">new</span> <span class="fu">Customer</span>(c.<span class="fu">Name</span>, a);</a>
<a class="sourceLine" id="cb5-6" title="6">}</a></code></pre></div>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/customer.jpg" width="900" /></p>
<p>So a lens picks out a single property inside a given object.</p>
<p>The power of lenses comes from their composability. Given a lens identifying a <code>T2</code> inside a <code>T1</code> (<code>ILens&lt;T1, T2&gt;</code>) and a lens identifying a <code>T3</code> inside a <code>T2</code> (<code>ILens&lt;T2, T3&gt;</code>), you can compose those lenses together to focus all the way from the <code>T1</code> to the <code>T3</code>.</p>
<p>You can traverse any relationship in your data model by composing together a small number of individual lenses. Composing lenses is so important that I‚Äôve given it the shortest name I can think of: <code>_</code>. (Readers of <a href="2018-03-16-eighty.html">an eariler post of mine</a> will know of my fondness for <code>_</code>.)</p>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/postcode.jpg" width="900" /></p>
<p>Compare this terse, declarative code with the tedious version of <code>UpdatePostcode</code> from the beginning:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb6-1" title="1">Order <span class="fu">UpdatePostcode</span>(Order order<span class="co">/*üë®üèª‚Äç‚öñÔ∏è*/</span>, <span class="dt">string</span> newPostcode)</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3">    ILens&lt;Order, <span class="dt">string</span>&gt; l = <span class="kw">new</span> <span class="fu">CustomerL</span>()</a>
<a class="sourceLine" id="cb6-4" title="4">        ._(<span class="kw">new</span> <span class="fu">AddressL</span>())</a>
<a class="sourceLine" id="cb6-5" title="5">        ._(<span class="kw">new</span> <span class="fu">PostcodeL</span>());</a>
<a class="sourceLine" id="cb6-6" title="6">    </a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">return</span> l.<span class="fu">Set</span>(order, newPostcode);</a>
<a class="sourceLine" id="cb6-8" title="8">}</a></code></pre></div>
<p>Lenses work without reference to any particular instance. (This is called <del><em>pointless</em></del> <a href="https://stackoverflow.com/questions/944446/what-is-point-free-style-in-functional-programming"><em>point-free</em></a> programming.) <code>order.Customer.Address.Postcode</code> becomes <code>new CustomerL()._(new AddressL())._(new PostcodeL())</code> ‚Äî the path of properties is sort of detached from the object itself. Treating a path through a datatype as a first class value is the big idea behind lenses.</p>
<p>Here‚Äôs how <code>_</code> is implemented. It returns a new <code>ILens</code> (an instance of a private class) which delegates to the two smaller lenses.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> ILens&lt;T1, T3&gt; _&lt;T1, T2, T3&gt;(<span class="kw">this</span> ILens&lt;T1, T2&gt; l1, ILens&lt;T2, T3&gt; l2)</a>
<a class="sourceLine" id="cb7-4" title="4">        =&gt; <span class="kw">new</span> ComposedLens&lt;T1, T2, T3&gt;(l1, l2);</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">private</span> <span class="kw">class</span> ComposedLens&lt;T1, T2, T3&gt; : ILens&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb7-7" title="7">    {</a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="kw">private</span> <span class="kw">readonly</span> ILens&lt;T1, T2&gt; _l1;</a>
<a class="sourceLine" id="cb7-9" title="9">        <span class="kw">private</span> <span class="kw">readonly</span> ILens&lt;T2, T3&gt; _l2;</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="kw">public</span> T3 <span class="fu">Get</span>(T1 obj) =&gt; _l2.<span class="fu">Get</span>(_l1.<span class="fu">Get</span>(obj));</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="kw">public</span> T1 <span class="fu">Set</span>(T1 oldObj, T3 newVal)</a>
<a class="sourceLine" id="cb7-14" title="14">            =&gt; _l1.<span class="fu">Set</span>(oldObj, _l2.<span class="fu">Set</span>(_l1.<span class="fu">Get</span>(oldObj), newVal));</a>
<a class="sourceLine" id="cb7-15" title="15">    }</a>
<a class="sourceLine" id="cb7-16" title="16">}</a></code></pre></div>
<p>To summarise, a lens is a way to focus on a small part of a big immutable structure. They‚Äôre like a first-class version of the <code>.</code> and <code>=</code> operators: you can compose lenses together to focus deeper, and upon focusing on a location you can get and set the value at that location.</p>
<h3 id="mapping-under-a-lens">Mapping under a lens</h3>
<p>A common pattern is to get a value from a lens, apply some sort of transformation to it, and then put it back where it was. The <code>Map</code> helper function wraps up this pattern:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb8-2" title="2">{</a>
<a class="sourceLine" id="cb8-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb8-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb8-7" title="7">        =&gt; <span class="fu">Set</span>(oldObj, <span class="fu">transformer</span>(<span class="fu">Get</span>(oldObj))).</a>
<a class="sourceLine" id="cb8-8" title="8">}</a></code></pre></div>
<p>Here‚Äôs an early taste of a default interface implementation. The default, <em><code>Get</code>-then-<code>Set</code></em>, works correctly, but when you‚Äôre working with deeply stacked lenses it can be inefficient to walk the whole data structure twice. (This is especially true of <em>multi-lenses</em> ‚Äî of which more later ‚Äî which build and discard a large number of intermediate enumerables.) If <code>Map</code> were an extension method, it would be impossible for users to override it and provide a more efficient implementation.</p>
<hr />
<p>Powerful as they are, these lenses don‚Äôt quite scale up to cover all of the important ways to access data. Specifically, they don‚Äôt support computed properties or lists.</p>
<h2 id="getters">Getters</h2>
<p>How would you write a lens which focuses on a list‚Äôs <code>Count</code>? You can‚Äôt set <code>Count</code> directly - it measures the number of times you‚Äôve added or removed something from the list. The only way to change the <code>Count</code> is to add or remove an item!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">class</span> CountL&lt;T&gt; : ILens&lt;ImmutableList&lt;T&gt;, <span class="dt">int</span>&gt;</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">Get</span>(ImmutableList&lt;T&gt; l) =&gt; l.<span class="fu">Count</span>;</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="kw">public</span> ImmutableList&lt;T&gt; <span class="fu">Set</span>(ImmutableList&lt;T&gt; l, <span class="dt">int</span> count) =&gt; <span class="co">/* ??? */</span>;</a>
<a class="sourceLine" id="cb9-5" title="5">}</a></code></pre></div>
<p>Clearly we need to separate the ‚Äúgetting‚Äù and ‚Äúsetting‚Äù reponsibilities of <code>ILens</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">interface</span> IGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb10-4" title="4">}</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb10-6" title="6">{</a>
<a class="sourceLine" id="cb10-7" title="7">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb10-8" title="8">}</a></code></pre></div>
<p>We don‚Äôt lose composability by doing this. You can still compose two getters to get a getter.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb11-2" title="2">{</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> IGetter&lt;T1, T3&gt; <span class="fu">_</span>(</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="kw">this</span> IGetter&lt;T1, T2&gt; g1,</a>
<a class="sourceLine" id="cb11-5" title="5">        IGetter&lt;T2, T3&gt; g2</a>
<a class="sourceLine" id="cb11-6" title="6">    ) =&gt; <span class="kw">new</span> ComposedGetter&lt;T1, T2, T3&gt;(g1, g2);</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">private</span> <span class="kw">class</span> ComposedGetter&lt;T1, T2, T3&gt; : IGetter&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb11-9" title="9">    {</a>
<a class="sourceLine" id="cb11-10" title="10">        <span class="kw">private</span> <span class="kw">readonly</span> IGetter&lt;T1, T2&gt; _g1;</a>
<a class="sourceLine" id="cb11-11" title="11">        <span class="kw">private</span> <span class="kw">readonly</span> IGetter&lt;T2, T3&gt; _g2;</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13">        <span class="kw">public</span> T3 <span class="fu">Get</span>(T1 obj) =&gt; _g2.<span class="fu">Get</span>(_g1.<span class="fu">Get</span>(obj));</a>
<a class="sourceLine" id="cb11-14" title="14">    }</a>
<a class="sourceLine" id="cb11-15" title="15">}</a></code></pre></div>
<p>If you compose a lens with a getter, you get a getter. This makes sense: if any part of a given path through a data structure is read-only, then the whole path must be read-only. It Just Works‚Ñ¢ because <code>ILens</code> is a subtype of <code>IGetter</code>. Overload resolution takes care of it: you type <code>_</code> and the compiler picks the right return type based on the types of <code>_</code>‚Äôs arguments.</p>
<h2 id="multi-lenses">Multi-lenses</h2>
<p><code>ILens</code> focuses on a single part of a structure. Its <code>Get</code> method returns a single <code>TProp</code> and its <code>Set</code> method takes a single <code>TProp</code>. This means you can‚Äôt use lenses to, for example, update the price of all the products in an order.</p>
<p>Enter <em>multi-lenses</em>, also known as <em>traversals</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">interface</span> IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb12-2" title="2">{</a>
<a class="sourceLine" id="cb12-3" title="3">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj);</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="co">// newVals should be the same length as the list returned by MultiGet</span></a>
<a class="sourceLine" id="cb12-5" title="5">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals);</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb12-8" title="8">        =&gt; <span class="fu">MultiSet</span>(oldObj, <span class="fu">MultiGet</span>(oldObj).<span class="fu">Select</span>(transformer)).</a>
<a class="sourceLine" id="cb12-9" title="9">}</a></code></pre></div>
<p>(Readers of <a href="2017-11-13-recursion-without-recursion.html">an earlier post</a> might recognise <code>IMultiLens</code> as a generalisation of <code>IRewriter</code>.) A multi-lens is like a lens which can hit more than one target. While a lens focuses on <em>exactly one</em> <code>TProp</code> inside a <code>T</code>, a multi-lens relaxes that restriction, focusing on <em>zero-or-many</em> <code>TProps</code> at once.</p>
<p>Here‚Äôs an example multi-lens which focuses on all of the <code>Product</code>s in an <code>Order</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">class</span> ProductsL : IMultiLens&lt;Order, Product&gt;</a>
<a class="sourceLine" id="cb13-2" title="2">{</a>
<a class="sourceLine" id="cb13-3" title="3">    IEnumerable&lt;Product&gt; <span class="fu">MultiGet</span>(Order order) =&gt; order.<span class="fu">Products</span>;</a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">    Order <span class="fu">MultiSet</span>(Order order, IEnumerable&lt;Product&gt; newProducts)</a>
<a class="sourceLine" id="cb13-6" title="6">        =&gt; <span class="kw">new</span> <span class="fu">Order</span>(order.<span class="fu">Customer</span>, newProducts);</a>
<a class="sourceLine" id="cb13-7" title="7">}</a></code></pre></div>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/products.jpg" width="900" /></p>
<p>You can compose multi-lenses, too. If you have a multi-lens which finds <span class="math inline"><em>n</em></span> <code>T2</code>s inside a <code>T1</code>, and a second multi-lens which finds <span class="math inline"><em>m</em></span> <code>T3</code>s inside a <code>T2</code>, you can build a multi-lens which finds <span class="math inline"><em>n</em><em>m</em></span> <code>T3</code>s inside a <code>T1</code>. This works by looking through the second multi-lens at all <span class="math inline"><em>n</em></span> of the first multi-lens‚Äôs targets.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb14-2" title="2">{</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> IMultiLens&lt;T1, T3&gt; <span class="fu">_</span>(</a>
<a class="sourceLine" id="cb14-4" title="4">        <span class="kw">this</span> IMultiLens&lt;T1, T2&gt; m1,</a>
<a class="sourceLine" id="cb14-5" title="5">        IMultiLens&lt;T2, T3&gt; m2</a>
<a class="sourceLine" id="cb14-6" title="6">    ) =&gt; <span class="kw">new</span> ComposedMultiLens&lt;T1, T2, T3&gt;(m1, m2);</a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="kw">private</span> <span class="kw">class</span> ComposedMultiLens&lt;T1, T2, T3&gt; : IMultiLens&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb14-9" title="9">    {</a>
<a class="sourceLine" id="cb14-10" title="10">        <span class="kw">private</span> <span class="kw">readonly</span> IMultiLens&lt;T1, T2&gt; _m1;</a>
<a class="sourceLine" id="cb14-11" title="11">        <span class="kw">private</span> <span class="kw">readonly</span> IMultiLens&lt;T2, T3&gt; _m2;</a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13">        <span class="kw">public</span> IEnumerable&lt;T3&gt; <span class="fu">MultiGet</span>(T1 obj)</a>
<a class="sourceLine" id="cb14-14" title="14">            =&gt; _m1.<span class="fu">MultiGet</span>(obj).<span class="fu">SelectMany</span>(_m2.<span class="fu">MultiGet</span>);</a>
<a class="sourceLine" id="cb14-15" title="15"></a>
<a class="sourceLine" id="cb14-16" title="16">        <span class="kw">public</span> T1 <span class="fu">MultiSet</span>(T1 oldObj, IEnumerable&lt;T3&gt; newVals)</a>
<a class="sourceLine" id="cb14-17" title="17">        {</a>
<a class="sourceLine" id="cb14-18" title="18">            IEnumerable&lt;T2&gt; <span class="fu">NewT2s</span>()</a>
<a class="sourceLine" id="cb14-19" title="19">            {</a>
<a class="sourceLine" id="cb14-20" title="20">                <span class="kw">foreach</span> (<span class="dt">var</span> x <span class="kw">in</span> _m1.<span class="fu">MultiGet</span>(oldObj))</a>
<a class="sourceLine" id="cb14-21" title="21">                {</a>
<a class="sourceLine" id="cb14-22" title="22">                    <span class="dt">var</span> chunkLength = _m2.<span class="fu">MultiGet</span>(x).<span class="fu">Count</span>();</a>
<a class="sourceLine" id="cb14-23" title="23">                    <span class="kw">yield</span> <span class="kw">return</span> _m2.<span class="fu">MultiSet</span>(x, newVals.<span class="fu">Take</span>(chunkLength));</a>
<a class="sourceLine" id="cb14-24" title="24">                    newVals = newVals.<span class="fu">Skip</span>(chunkLength);</a>
<a class="sourceLine" id="cb14-25" title="25">                }</a>
<a class="sourceLine" id="cb14-26" title="26">            }</a>
<a class="sourceLine" id="cb14-27" title="27">            <span class="kw">return</span> _m1.<span class="fu">MultiSet</span>(oldObj, <span class="fu">NewT2s</span>());</a>
<a class="sourceLine" id="cb14-28" title="28">        }</a>
<a class="sourceLine" id="cb14-29" title="29">    }</a>
<a class="sourceLine" id="cb14-30" title="30">}</a></code></pre></div>
<p><code>MultiSet</code> chops <code>newVals</code> into chunks that are the length of each group of descendants. This is safe as long as a user never calls <code>MultiSet</code> with a different number of elements than was returned by <code>MultiGet</code>.</p>
<p>So far we can compose multi-lenses on their own, but they don‚Äôt yet interoperate well with lenses. But note multi-lenses generalise lenses by relaxing the requirement that there should be exactly one substructure. Every lens is also a multi-lens by forgetting that there‚Äôs a single <code>TProp</code>. (Once again we‚Äôre relying on the assumption that the list does not change length in between <code>MultiGet</code> and <code>MultiSet</code> calls.)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb15-2" title="2">{</a>
<a class="sourceLine" id="cb15-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb15-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj)</a>
<a class="sourceLine" id="cb15-7" title="7">        =&gt; <span class="kw">new</span>[] { <span class="fu">Get</span>(obj) };</a>
<a class="sourceLine" id="cb15-8" title="8">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals)</a>
<a class="sourceLine" id="cb15-9" title="9">        =&gt; <span class="fu">Set</span>(oldObj, newVals.<span class="fu">Single</span>());</a>
<a class="sourceLine" id="cb15-10" title="10">}</a></code></pre></div>
<p>Inheriting from <code>IMultiLens</code> like this is just the same trick as inheriting from <code>IGetter</code>. It allows you to compose a lens with a multi-lens using <code>_</code>; the result will be a multi-lens.</p>
<p>If lenses are like a first-class <code>.</code>, then multi-lenses are like a first-class <code>Select</code>. Composing a lens onto the end of a multi-lens is like <code>Select</code>ing a field from each element of a list, with the added power of being able to write new values to the list. Like lenses, multi-lenses are point-free: you compose a multi-lens describing a path through a datatype, then apply that multi-lens to a specific instance of the datatype.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb16-1" title="1">Order <span class="fu">TwentyPercentOff</span>(Order order)</a>
<a class="sourceLine" id="cb16-2" title="2">{</a>
<a class="sourceLine" id="cb16-3" title="3">    IMultiLens&lt;Order, <span class="dt">decimal</span>&gt; l = <span class="kw">new</span> <span class="fu">ProductsL</span>()._(<span class="kw">new</span> <span class="fu">PriceL</span>());</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="kw">return</span> l.<span class="fu">Map</span>(order, x =&gt; x * <span class="fl">0.8</span>);</a>
<a class="sourceLine" id="cb16-5" title="5">}</a></code></pre></div>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/product-and-price.jpg" width="900" /></p>
<p>Incorporating the earlier <code>IGetter</code> fix, and extending <code>IMultiLens</code> upwards in parallel, leaves us with the following hierarchy.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">interface</span> IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-2" title="2">{</a>
<a class="sourceLine" id="cb17-3" title="3">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj);</a>
<a class="sourceLine" id="cb17-4" title="4">}</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">interface</span> IMultiLens&lt;T, TProp&gt; : IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-6" title="6">{</a>
<a class="sourceLine" id="cb17-7" title="7">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals);</a>
<a class="sourceLine" id="cb17-8" title="8"></a>
<a class="sourceLine" id="cb17-9" title="9">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb17-10" title="10">        =&gt; <span class="fu">MultiSet</span>(oldObj, <span class="fu">MultiGet</span>(oldObj).<span class="fu">Select</span>(transformer));</a>
<a class="sourceLine" id="cb17-11" title="11">}</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="kw">interface</span> IGetter&lt;T, TProp&gt; : IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-13" title="13">{</a>
<a class="sourceLine" id="cb17-14" title="14">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb17-15" title="15"></a>
<a class="sourceLine" id="cb17-16" title="16">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj)</a>
<a class="sourceLine" id="cb17-17" title="17">        =&gt; <span class="kw">new</span>[] { <span class="fu">Get</span>(obj) };</a>
<a class="sourceLine" id="cb17-18" title="18">}</a>
<a class="sourceLine" id="cb17-19" title="19"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IGetter&lt;T, TProp&gt;, IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-20" title="20">{</a>
<a class="sourceLine" id="cb17-21" title="21">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb17-22" title="22"></a>
<a class="sourceLine" id="cb17-23" title="23">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals)</a>
<a class="sourceLine" id="cb17-24" title="24">        =&gt; <span class="fu">Set</span>(oldObj, newVals.<span class="fu">Single</span>());</a>
<a class="sourceLine" id="cb17-25" title="25">}</a></code></pre></div>
<p><img src="../images/2018-12-06-zooming-in-on-field-accessors/hierarchy.jpg" width="900" /></p>
<h2 id="default-interface-implementations">Default Interface Implementations</h2>
<p>The code above makes central use of default interface implementations, so it‚Äôs probably time to talk about what they are.</p>
<p>In C#8, interfaces won‚Äôt just be type declarations any more. You‚Äôll be allowed to write code in an interface method, to function as the default implementation of that method. Typically it‚Äôll be written in terms of the other methods on the interface, like an extension method. They differ from extension methods, however, in that they are virtual. If an implementing class has a better (faster, typically) way of implementing the operation, it‚Äôs free to override it.</p>
<p>Here‚Äôs an example. How would LINQ‚Äôs design look different if default interface methods had been around at the time? Today‚Äôs <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.count"><code>Count</code></a> method, an extension method, works in linear time by counting up all of the elements of the input <code>IEnumerable</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">public</span> <span class="kw">static</span> <span class="dt">int</span> Count&lt;T&gt;(<span class="kw">this</span> IEnumerable&lt;T&gt; source)</a>
<a class="sourceLine" id="cb18-2" title="2">{</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="dt">var</span> count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="kw">foreach</span> (<span class="dt">var</span> _ <span class="kw">in</span> source)</a>
<a class="sourceLine" id="cb18-5" title="5">    {</a>
<a class="sourceLine" id="cb18-6" title="6">        count++;</a>
<a class="sourceLine" id="cb18-7" title="7">    }</a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="kw">return</span> count;</a>
<a class="sourceLine" id="cb18-9" title="9">}</a></code></pre></div>
<p>However, there are certain implementations of <code>IEnumerable</code> which can count themselves much faster than that:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">class</span> List&lt;T&gt; : IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb19-2" title="2">{</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="kw">private</span> T[] _array;</a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="kw">private</span> <span class="dt">int</span> _count;</a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="kw">public</span> <span class="dt">int</span> Count =&gt; _count;</a>
<a class="sourceLine" id="cb19-9" title="9">}</a></code></pre></div>
<p><a href="https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Count.cs">The real <code>Count</code> extension method</a> takes a fast path when its argument happens to be an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1?view=netframework-4.7.2"><code>ICollection</code></a>, but that doesn‚Äôt scale well. Not every <code>IEnumerable</code> which admits a fast <code>Count</code> can also implement <code>ICollection</code> ‚Äî for example, an immutable collection can‚Äôt implement the <code>void Add(T item)</code> method.</p>
<p>If LINQ had been designed not as a collection of extension methods but as a collection of default interface methods, it‚Äôd be possible to override <code>Count</code> in an extensible way:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">interface</span> IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb20-2" title="2">{</a>
<a class="sourceLine" id="cb20-3" title="3">    IEnumerator&lt;T&gt; <span class="fu">GetEnumerator</span>();</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5">    <span class="dt">int</span> <span class="fu">Count</span>()</a>
<a class="sourceLine" id="cb20-6" title="6">    {</a>
<a class="sourceLine" id="cb20-7" title="7">        <span class="dt">var</span> count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-8" title="8">        <span class="kw">foreach</span> (<span class="dt">var</span> _ <span class="kw">in</span> source)</a>
<a class="sourceLine" id="cb20-9" title="9">        {</a>
<a class="sourceLine" id="cb20-10" title="10">            count++;</a>
<a class="sourceLine" id="cb20-11" title="11">        }</a>
<a class="sourceLine" id="cb20-12" title="12">        <span class="kw">return</span> count;</a>
<a class="sourceLine" id="cb20-13" title="13">    }</a>
<a class="sourceLine" id="cb20-14" title="14">    <span class="co">// other methods like Select etc</span></a>
<a class="sourceLine" id="cb20-15" title="15">}</a>
<a class="sourceLine" id="cb20-16" title="16"></a>
<a class="sourceLine" id="cb20-17" title="17"><span class="kw">class</span> List&lt;T&gt; : IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb20-18" title="18">{</a>
<a class="sourceLine" id="cb20-19" title="19">    <span class="kw">private</span> T[] _array;</a>
<a class="sourceLine" id="cb20-20" title="20">    <span class="kw">private</span> <span class="dt">int</span> _count;</a>
<a class="sourceLine" id="cb20-21" title="21">    </a>
<a class="sourceLine" id="cb20-22" title="22">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb20-23" title="23"></a>
<a class="sourceLine" id="cb20-24" title="24">    <span class="co">// override the default version from IEnumerable</span></a>
<a class="sourceLine" id="cb20-25" title="25">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">Count</span>() =&gt; _count;</a>
<a class="sourceLine" id="cb20-26" title="26">}</a></code></pre></div>
<p>Interfaces with default methods are somewhat like abstract classes with virtual methods. The main difference is that a class can implement multiple interfaces, while it can only derive from one class. So default interface implementations amount to a form of multiple inheritance! (This provoked much whingeing in <a href="https://github.com/dotnet/csharplang/issues/288">the discussion on GitHub</a>.)</p>
<p>The optics library I‚Äôve outlined above makes central use of multiple inheritance. <code>ILens</code> inherits its <code>MultiGet</code> implementation from <code>IGetter</code> and its <code>Map</code> implementation from <code>IMultiLens</code>. So it wouldn‚Äôt work with abstract classes; before C#8 we wouldn‚Äôt have been able to write this program. Default interface implementations add new expressive power to the language.</p>
<h2 id="production-worthiness">Production-Worthiness</h2>
<p>Lenses are very useful in functional languages, but I would not recommend you use them in practical C#, even after the release of C#8. When you stand it next to <a href="http://hackage.haskell.org/package/lens">Haskell‚Äôs <code>lens</code> library</a>, the API I outlined above has a number of significant shortcomings.</p>
<ul>
<li><p><strong>Performance</strong>. The big one! Accessing a field is such a common operation that it‚Äôd better be fast. The <code>.</code> operator (<code>order.Customer.Address.Postcode</code>) is very fast on the CLR ‚Äî just a pointer hop. Composed lenses, on the other hand, are tree-shaped objects, and calling <code>Get</code> means traversing that tree with a interface method call at each level. I ran some rudimentary benchmarks and found deeply nested lenses to be orders of magnitude slower than equivalent lensless code.</p>
<p>The <code>lens</code> library sidesteps this performance issue by leaning on Haskell‚Äôs optimising compiler. <code>lens</code> has been carefully designed to be easy for GHC to optimise, and the result is that GHC generally produces identical machine code for equivalent lensy and lensless functions.</p></li>
<li><p><strong>Code generation</strong>. Almost all of the atomic lens classes you‚Äôd write for a business system are pure boilerplate ‚Äî exactly the sort of thing you‚Äôd expect a machine to write. You should be able to define an object, perhaps mark it up using an attribute, and get on with using lenses into that object in the rest of your program, with Intellisense support. You shouldn‚Äôt ever need to see a lens‚Äôs source code. Roslyn, the C# compiler, has no facilities for compile-time code injection like this. A lens library could bundle a source code generator, perhaps using Roslyn‚Äôs API, which users run ahead-of-time ‚Äî many ORMs do this ‚Äî but that‚Äôs a much less compelling user experience.</p>
<p>This may be a good use case for F#‚Äôs type providers. (In any case F# places more emphasis on immutability than C#, making lenses a more natural fit in the first place.) Presently you can‚Äôt use a type provider to generate code based on another type (though <a href="https://github.com/fsharp/fslang-design/issues/125">it appears to be planned</a>), and <a href="https://github.com/fsharp/fslang-suggestions/issues/679#issuecomment-399411192">there don‚Äôt seem to be plans</a> to support multiple inheritance in the F# source language. In principle one could implement the hierarchy in C# and consume it from an F# type provider.</p></li>
<li>Two ergonomic complaints regarding C#‚Äôs support for <strong>generics</strong>:
<ul>
<li><p><strong>Type inference</strong>. C# has only minimal support for type inference. This makes generic lenses unpleasant to use. The following lens picks out a <code>KeyValuePair</code>‚Äôs <code>Value</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">class</span> ValueL&lt;K, V&gt; : ILens&lt;KeyValuePair&lt;K, V&gt;, V&gt;</a>
<a class="sourceLine" id="cb21-2" title="2">{</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">public</span> V <span class="fu">Get</span>(KeyValuePair&lt;K, V&gt; kvp) =&gt; kvp.<span class="fu">Value</span>;</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="kw">public</span> KeyValuePair&lt;K, V&gt; <span class="fu">Set</span>(KeyValuePair&lt;K, V&gt; kvp, V val)</a>
<a class="sourceLine" id="cb21-5" title="5">        =&gt; <span class="kw">new</span> KeyValuePair&lt;K, V&gt;(kvp.<span class="fu">Key</span>, val);</a>
<a class="sourceLine" id="cb21-6" title="6">}</a></code></pre></div>
<p>You can‚Äôt use <code>ValueL</code> without explicitly mentioning the concrete type parameters at which you‚Äôre using it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">new</span> ValueL&lt;<span class="dt">string</span>, <span class="dt">int</span>&gt;().<span class="fu">Set</span>(<span class="kw">new</span> KeyValuePair&lt;<span class="dt">string</span>, <span class="dt">int</span>&gt;(<span class="st">&quot;foo&quot;</span>, <span class="dv">3</span>), <span class="dv">7</span>);</a></code></pre></div>
<p>Ideally the compiler would be able to deduce the <code>&lt;string, int&gt;</code> part by noticing that we‚Äôre using it on a <code>KeyValuePair&lt;string, int&gt;</code>. This is difficult to implement in a subtyping-based language, though.</p></li>
<li><p><strong>Generic type aliases</strong>. <a href="http://comonad.com/reader/2012/mirrored-lenses/">The most general formulation of lenses</a> actually has <em>four</em> type parameters: <code>ILens&lt;in S, out T, out A, in B&gt;</code>! This is to support lenses into generic types, allowing you to change the type of the resulting structure by writing a different type into the lens. (<code>new ValueL().Set(new KeyValuePair&lt;string, string&gt;(&quot;foo&quot;, &quot;bar&quot;), 3)</code> should return a <code>KeyValuePair&lt;string, int&gt;</code> ‚Äî that is, a new <code>KeyValuePair</code> with a different type to the original.)</p>
<p>The old <code>ILens&lt;S, A&gt;</code> is then equivalent to <code>ILens&lt;S, S, A, A&gt;</code>. Ideally we‚Äôd be able to define a <em>type alias</em>, so that you can type <code>ILens&lt;S, A&gt;</code> for <code>ILens&lt;S, S, A, A&gt;</code>, but C# doesn‚Äôt support this. (<a href="https://github.com/dotnet/roslyn/issues/3993">A modest proposed extension to <code>using</code></a> would largely service this complaint, reducing the noise to a few lines of boilerplate at the top of each file.)</p></li>
</ul></li>
<li><p><strong>Noisy syntax</strong>. Haskell allows you to define custom symbolic operators, and <code>lens</code> ships a large collection of operators to debigulate your code. <code>new CustomerL()._(new AddressL())._(new PostcodeL()).Get(order)</code> is clunky in comparison to Haskell‚Äôs cute OO-style <code>order^.customer.address.postcode</code>.</p>
<ul>
<li>Related to this concern is <strong>namespacing</strong>. Above I‚Äôve used a convention of appending the letter <code>L</code> to lens classes (<code>CustomerL</code>), but that starts to break down when you have more than one property with the same name in your system. One option might be to nest the lenses inside the objects themselves and import them with <code>using static</code>.</li>
</ul></li>
<li><p><strong>Platform compatibility</strong>. According to <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">a recent announcement</a>, default interface implementations are only going to be available on .NET Core, and won‚Äôt be in the desktop framework for the foreseeable future. As I understand it, the desktop CLR‚Äôs stringent backwards compatibility requirements make testing a wide-reaching CLR feature like this difficult and expensive. But to me, a library author, this is a very disappointing development: libraries <em>must</em> support the desktop CLR if they expect to have any users, so locking down features designed for library authors seems like a misfire. I‚Äôd prefer it if Microsoft just said directly that the desktop framework is being sunsetted ‚Äî that way I‚Äôd at least have some ammunition for GitHub issues.</p></li>
</ul>
<p>All that said, there are a couple of things which I find preferable about this design when compared to <code>lens</code>. Haskell doesn‚Äôt feature subtyping directly, so <code>lens</code> uses a clever function-based encoding of its type hierarchy, using the type class solver to handle the various subtype relationships. Encoding lenses as functions is partly why <code>lens</code> is so fast, but it does make for a steep learning curve and notoriously confusing type errors. Using a more direct representation of subtyping means the model is clearer, and it‚Äôs easier to see how one would slot (eg) prisms or indexed lenses into the system I outlined above. What‚Äôs more, the four-parameter version of <code>ILens</code> I mentioned above is variously co- and contra-variant in its parameters, meaning it interoperates well with the rest of C#‚Äôs type hierarchy. In some sense these lenses are <em>more</em> composable than <code>lens</code>‚Äôs lenses.</p>
<p>I‚Äôd love to tell you I‚Äôve written this up as a published library, but the shortfalls I noted above make this formulation of lenses impractical for real-world use. I‚Äôd love to hear your ideas on how to improve the situation! In the meantime, I bagsie the name <code>OptiCS</code>.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on December  6, 2018</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/live/comments/2018-12-06-zooming-in-on-field-accessors/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
