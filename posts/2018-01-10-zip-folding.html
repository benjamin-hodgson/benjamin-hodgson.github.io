<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>benjamin.pizza - Zip-Folding</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2.1.1/out/water.min.css" integrity="sha256-QST90Wzz4PEr5KlclQaOCsjc00FTyf86Wrj41oqZB4w=" crossorigin="anonymous" />
        <link rel="stylesheet" type="text/css" href="../all.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>

        <script async id="highlightjs-script" src="../js/third-party/highlight.js"></script>
        <script async src="../js/main.js"></script>
    </head>
    <body>
        <header id="header">
            <nav id="navigation">
                <ul>
                    <li id="logo"><a href="../">benjamin.pizza</a></li>
                    <li><a href="../contact.html">Contact</a></li>
                    <li><a href="../archive.html">Archive</a></li>
                    <li><a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a></li>
                </ul>
            </header>
        </header>

        <article>
            <header>
                <h1>Zip-Folding</h1>
                
                
                    <p><time datetime="2018-01-10">January 10, 2018</time></p>
                
            </header>

            
<p>One of my favourite little gems of functional programming is the following implementation of the dot product:</p>
<pre><code class="language-haskell">dot :: [Double] -&gt; [Double] -&gt; Double
xs `dot` ys = sum (zipWith (*) xs ys)
</code></pre>
<p><code>dot</code> zips two lists of numbers, multiplying each pair of elements using <code>(*)</code>, and then aggregates the results with <code>sum</code>. It’s like a <em>map-reduce</em> program, but it processes two collections, not one. It generalises rather beautifully to any zippily <code>Applicative</code> <code>Foldable</code> container whose elements form a <code>Semiring</code>:</p>
<pre><code class="language-haskell">dot :: (Semiring a, Applicative t, Foldable t) =&gt; t a -&gt; t a -&gt; a
xs `dot` ys = foldl' (&lt;+&gt;) zero (liftA2 (&lt;.&gt;) xs ys)
</code></pre>
<p>I think I’m particularly taken with this example because it combines three different abstractions in a totally natural way to produce a concise and generic implementation of a well-known program. It’s a beautiful demonstration of how these mathematical tools fit together. It also happens to be an example of a programming pattern that I call <em>zip-folding</em>.</p>
<hr />
<p>Until recently I felt rather embarrassed that my C# generic programming library <a href="https://github.com/benjamin-hodgson/Sawmill">Sawmill</a> didn’t have a good story for consuming more than one tree at a time. I had lots of tools for <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.SelfAndDescendants.cs">querying</a>, <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Rewrite.cs">editing</a>, and <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Fold.cs">tearing down</a> single trees, but nothing that could help you process two trees at once. This is a very common requirement - for example, if you’re unit testing a parser or a transformation pass, you need to compare the output tree to the one that you expected.</p>
<p>I got to thinking about what it means to zip two trees together - an operation which should make sense if you think of a tree as a container of subtrees. Pairing up nodes in a tree is straightforward, even if the two trees are unevenly shaped. You just pair up the children of each pair of nodes, ignoring those which don’t have a partner (the grey-coloured ones in the drawing):</p>
<img src="../images/2018-01-10-zip-folding/zip.jpg" alt="Pairing up nodes" />
<p>But I got stuck on how to plug those paired nodes back into a single tree representing the zipped trees. Nodes typically have space for a fixed number of children, but pairing up children will typically change that number. That is, a binary operator has precisely two children, but when zipping two binary operators together you need to do something with four children.</p>
<p>And, more generally, what would it mean to zip trees recursively? You can imagine a scheme wherein each child of a node is replaced with a tuple of two children. But each child is really a subtree, with its own children, so the two subtrees need to be zipped - but that ought to produce a single tree, not a pair of trees. It’s contradictory! The intuitive idea that a node in a tree is a container of subtrees fails when you consider zipping.</p>
<hr />
<p>Guess where this is going: you can’t <em>zip</em> trees to produce a new tree, but you can <em>zip-fold</em> trees to produce a value. The idea is to take pairs of nodes in a tree and combine them with the results of zipping their children.</p>
<p>Let’s start by looking at (an abbreviated version of) Sawmill’s existing <code>Fold</code>. <code>Fold</code> says <em>if you give me a way to combine a node with the results of folding its children, I can recursively fold the entire tree to produce a single summary value</em>.</p>
<pre><code class="language-csharp">public static U Fold&lt;T, U&gt;(
    this T value,
    Func&lt;T, Children&lt;U&gt;, U&gt; func,
) where T : IRewritable&lt;T&gt;
    =&gt; func(
        value,
        value.GetChildren()
            .Select(child =&gt; child.Fold(func))
    );
</code></pre>
<p>Revisiting <a href="https://www.benjamin.pizza/posts/2017-11-13-recursion-without-recursion.html">the JQL example</a>, <code>Fold</code> will take an input tree like <code>[c#] and (not [javascript] or salary:50000gbp)</code> and compute the expression:</p>
<pre><code class="language-csharp">func(
    new AndNode(/* ... */),
    Children.Two(
        func(new TagNode(&quot;c#&quot;), Children.None&lt;U&gt;()),
        func(
            new OrNode(/* ... */),
            Children.Two(
                func(
                    new NotNode(/* ... */),
                    Children.One(
                        func(
                            new TagNode(&quot;javascript&quot;),
                            Children.None&lt;U&gt;()
                        )
                    )
                ),
                func(new SalaryNode(50000, &quot;gbp&quot;), Children.None&lt;U&gt;())
            )
        )
    )
)
</code></pre>
<p><code>Fold</code> traverses a tree from bottom to top, applying <code>func</code> to each subtree and the current set of intermediate results.</p>
<p><code>ZipFold</code> works by analogy to <code>Fold</code>. It says <em>if you give me a way to combine two nodes with the results of zip-folding their children, I can recursively zip the two entire trees to produce a single summary value</em>. <code>ZipFold</code> pairs up the children of the two input nodes using the standard <code>Enumerable.Zip</code>, recursively zip-folds each pair, and then feeds the results to <code>func</code>. Note that the length of the <code>IEnumerable</code> that’s passed to <code>func</code> is the length of the smaller of the two nodes’ collections of children.</p>
<pre><code class="language-csharp">public static U ZipFold&lt;T, U&gt;(
    this T value1,
    T value2
    Func&lt;T, T, IEnumerable&lt;U&gt;, U&gt; zipFunc,
) where T : IRewritable&lt;T&gt;
    =&gt; zipFunc(
        value1,
        value2,
        value1.GetChildren().Zip(
            value2.GetChildren(),
            (child1, child2) =&gt; child1.ZipFold(child2, zipFunc)
        )
    );
</code></pre>
<p>The two trees are zipped together and torn down in a single pass.</p>
<p>Here’s how it looks in Haskell, using the <a href="https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html"><code>Control.Lens.Plated</code></a> API. Haskellers like to use tongue-in-cheek Greek names for recursion schemes. Apparently the Greek word for “zip” is “fermouár”, so I’m calling this a <em>fermomorphism</em>.</p>
<pre><code class="language-haskell">fermo :: Plated a =&gt; (a -&gt; a -&gt; [r] -&gt; r) -&gt; a -&gt; a -&gt; r
fermo f x y = f x y $
    zipWith (fermo f) (toListOf plate x) (toListOf plate y)
</code></pre>
<p>As an example: <code>ZipFold</code> allows you to concisely test a pair of trees for equality, by looking only at one pair of nodes at a time.</p>
<pre><code class="language-csharp">public static bool Equal(JqlNode j1, JqlNode j2)
    =&gt; j1.ZipFold&lt;JqlNode, bool&gt;(
        j2,
        (n1, n2, childrenEqual) =&gt;
        {
            switch (n1)
            {
                case SalaryNode s1 when n2 is SalaryNode s2:
                    return s1.Currency == s2.Currency
                        &amp;&amp; s1.Amount == s2.Amount;
                case TagNode t1 when n2 is TagNode t2:
                    return t1.Tag == t2.Tag;
                case AndNode a1 when n2 is AndNode a2:
                case OrNode o1 when n2 is OrNode o2:
                case NotNode a1 when n2 is NotNode a2:
                    return childrenEqual.All(c =&gt; c);
                default:
                    return false;
            }
        }
    );
</code></pre>
<p>The <code>ZipFold</code> that you’ll find in Sawmill is actually an <em>n</em>-ary zip-fold. Instead of taking two <code>T</code>s, and passing two <code>T</code>s to <code>func</code>, it works with an arbitrary number of <code>T</code>s. Here’s the code:</p>
<pre><code class="language-csharp">public static U ZipFold&lt;T, U&gt;(
    this T[] values,
    Func&lt;T[], IEnumerable&lt;U&gt;, U&gt; func,
) where T : IRewritable&lt;T&gt;
    =&gt; func(values, xs.ZipChildren(children =&gt; children.ZipFold(func)));

private static IEnumerable&lt;U&gt; ZipChildren&lt;T, U&gt;(
    this T[] input,
    Func&lt;T[], U&gt; zipFunc
) where T : IRewritable&lt;T&gt;
{
    var enumerators = input
        .Select(x =&gt; x.GetChildren().GetEnumerator())
        .ToArray();

    while (enumerators.All(e =&gt; e.MoveNext()))
    {
        yield return zipFunc(
            enumerators.Select(e =&gt; e.Current).ToArray()
        );
    }
}
</code></pre>
<p>Sadly, the invariant that <code>zipFunc</code> receives the same number of <code>T</code>s as were passed to <code>ZipFold</code> is not expressible in C#’s type system. So as a consumer of <code>ZipFold</code>, you just have to trust that <code>zipFunc</code>’s argument is of a certain size. In the <code>Equal</code> example, that size is two, because we’re consuming two trees:</p>
<pre><code class="language-csharp">public static bool Equal(JqlNode j1, JqlNode j2)
    =&gt; new[] { j1, j2 }.ZipFold&lt;JqlNode, bool&gt;(
        (ns, childrenEqual) =&gt;
        {
            switch (ns[0])
            {
                case SalaryNode s1 when ns[1] is SalaryNode s2:
                    return s1.Currency == s2.Currency
                        &amp;&amp; s1.Amount == s2.Amount;
                case TagNode t1 when ns[1] is TagNode t2:
                    return t1.Tag == t2.Tag;
                case AndNode a1 when ns[1] is AndNode a2:
                case OrNode o1 when ns[1] is OrNode o2:
                case NotNode n1 when ns[1] is NotNode n2:
                    return childrenEqual.All(c =&gt; c);
                default:
                    return false;
            }
        }
    );
</code></pre>
<p>Here’s the Haskell transliteration of this <em>n</em>-ary zip-fold function, which <code>traverse</code>s in the <code>ZipList</code> <code>Applicative</code> to concisely zip <em>n</em> lists of children:</p>
<pre><code class="language-haskell">fermo :: Plated a =&gt; ([a] -&gt; [r] -&gt; r) -&gt; [a] -&gt; r
fermo f xs = f xs (
    map (fermo f) $ getZipList $ traverse (ZipList . toListOf plate) xs
    )
</code></pre>
<p><code>ZipFold</code> is available in <a href="https://www.nuget.org/packages/Sawmill/">version 1.3.0 of Sawmill</a>.</p>


        </article>

        <footer id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
