<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>benjamin.pizza - Zip-Folding</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2.1.1/out/water.min.css" integrity="sha256-QST90Wzz4PEr5KlclQaOCsjc00FTyf86Wrj41oqZB4w=" crossorigin="anonymous" />
        <link rel="stylesheet" type="text/css" href="../all.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>
    </head>
    <body>
        <header id="header">
            <nav id="navigation">
                <ul>
                    <li id="logo"><a href="../">benjamin.pizza</a></li>
                    <li><a href="../about.html">About</a></li>
                    <li><a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a></li>
                </ul>
            </nav>
        </header>

        <article>
            <header>
                <h1>Zip-Folding</h1>
                
                
                    <p><time datetime="2018-01-10">January 10, 2018</time></p>
                
            </header>

            
<p>One of my favourite little gems of functional programming is the following implementation of the dot product:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">`dot`</span> ys <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">zipWith</span> (<span class="op">*</span>) xs ys)</span></code></pre></div><p><code>dot</code> zips two lists of numbers, multiplying each pair of elements using <code>(*)</code>, and then aggregates the results with <code>sum</code>. It’s like a <em>map-reduce</em> program, but it processes two collections, not one. It generalises rather beautifully to any zippily <code>Applicative</code> <code>Foldable</code> container whose elements form a <code>Semiring</code>:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">`dot`</span> ys <span class="ot">=</span> foldl' (<span class="op">&lt;+&gt;</span>) zero (liftA2 (<span class="op">&lt;.&gt;</span>) xs ys)</span></code></pre></div><p>I think I’m particularly taken with this example because it combines three different abstractions in a totally natural way to produce a concise and generic implementation of a well-known program. It’s a beautiful demonstration of how these mathematical tools fit together. It also happens to be an example of a programming pattern that I call <em>zip-folding</em>.</p>
<hr />
<p>Until recently I felt rather embarrassed that my C# generic programming library <a href="https://github.com/benjamin-hodgson/Sawmill">Sawmill</a> didn’t have a good story for consuming more than one tree at a time. I had lots of tools for <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.SelfAndDescendants.cs">querying</a>, <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Rewrite.cs">editing</a>, and <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Fold.cs">tearing down</a> single trees, but nothing that could help you process two trees at once. This is a very common requirement - for example, if you’re unit testing a parser or a transformation pass, you need to compare the output tree to the one that you expected.</p>
<p>I got to thinking about what it means to zip two trees together - an operation which should make sense if you think of a tree as a container of subtrees. Pairing up nodes in a tree is straightforward, even if the two trees are unevenly shaped. You just pair up the children of each pair of nodes, ignoring those which don’t have a partner (the grey-coloured ones in the drawing):</p>
<img src="../images/2018-01-10-zip-folding/zip.jpg" alt="Pairing up nodes" />
<p>But I got stuck on how to plug those paired nodes back into a single tree representing the zipped trees. Nodes typically have space for a fixed number of children, but pairing up children will typically change that number. That is, a binary operator has precisely two children, but when zipping two binary operators together you need to do something with four children.</p>
<p>And, more generally, what would it mean to zip trees recursively? You can imagine a scheme wherein each child of a node is replaced with a tuple of two children. But each child is really a subtree, with its own children, so the two subtrees need to be zipped - but that ought to produce a single tree, not a pair of trees. It’s contradictory! The intuitive idea that a node in a tree is a container of subtrees fails when you consider zipping.</p>
<hr />
<p>Guess where this is going: you can’t <em>zip</em> trees to produce a new tree, but you can <em>zip-fold</em> trees to produce a value. The idea is to take pairs of nodes in a tree and combine them with the results of zipping their children.</p>
<p>Let’s start by looking at (an abbreviated version of) Sawmill’s existing <code>Fold</code>. <code>Fold</code> says <em>if you give me a way to combine a node with the results of folding its children, I can recursively fold the entire tree to produce a single summary value</em>.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> U Fold<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;(</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span> T value<span class="op">,</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    Func<span class="op">&lt;</span>T<span class="op">,</span> Children<span class="op">&lt;</span>U<span class="op">&gt;,</span> U<span class="op">&gt;</span> func</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> where T <span class="op">:</span> IRewritable<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="fu">func</span><span class="op">(</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>        value<span class="op">,</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>        value<span class="op">.</span><span class="fu">GetChildren</span><span class="op">()</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">Select</span><span class="op">(</span>child <span class="op">=&gt;</span> child<span class="op">.</span><span class="fu">Fold</span><span class="op">(</span>func<span class="op">))</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span></code></pre></div><p>Revisiting <a href="https://www.benjamin.pizza/posts/2017-11-13-recursion-without-recursion.html">the JQL example</a>, <code>Fold</code> will take an input tree like <code>[c#] and (not [javascript] or salary:50000gbp)</code> and compute the expression:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fu">func</span><span class="op">(</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="fu">AndNode</span><span class="op">(</span><span class="co">/* ... */</span><span class="op">),</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    Children<span class="op">.</span><span class="fu">Two</span><span class="op">(</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">func</span><span class="op">(</span><span class="kw">new</span> <span class="fu">TagNode</span><span class="op">(</span><span class="st">&quot;c#&quot;</span><span class="op">),</span> Children<span class="op">.</span><span class="fu">None</span><span class="op">&lt;</span>U<span class="op">&gt;()),</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">func</span><span class="op">(</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">OrNode</span><span class="op">(</span><span class="co">/* ... */</span><span class="op">),</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>            Children<span class="op">.</span><span class="fu">Two</span><span class="op">(</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>                <span class="fu">func</span><span class="op">(</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">NotNode</span><span class="op">(</span><span class="co">/* ... */</span><span class="op">),</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>                    Children<span class="op">.</span><span class="fu">One</span><span class="op">(</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">func</span><span class="op">(</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">new</span> <span class="fu">TagNode</span><span class="op">(</span><span class="st">&quot;javascript&quot;</span><span class="op">),</span></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>                            Children<span class="op">.</span><span class="fu">None</span><span class="op">&lt;</span>U<span class="op">&gt;()</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>                        <span class="op">)</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>                    <span class="op">)</span></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>                <span class="op">),</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>                <span class="fu">func</span><span class="op">(</span><span class="kw">new</span> <span class="fu">SalaryNode</span><span class="op">(</span><span class="dv">50000</span><span class="op">,</span> <span class="st">&quot;gbp&quot;</span><span class="op">),</span> Children<span class="op">.</span><span class="fu">None</span><span class="op">&lt;</span>U<span class="op">&gt;())</span></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>            <span class="op">)</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="21"><a href="#21" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div><p><code>Fold</code> traverses a tree from bottom to top, applying <code>func</code> to each subtree and the current set of intermediate results.</p>
<p><code>ZipFold</code> works by analogy to <code>Fold</code>. It says <em>if you give me a way to combine two nodes with the results of zip-folding their children, I can recursively zip the two entire trees to produce a single summary value</em>. <code>ZipFold</code> pairs up the children of the two input nodes using the standard <code>Enumerable.Zip</code>, recursively zip-folds each pair, and then feeds the results to <code>func</code>. Note that the length of the <code>IEnumerable</code> that’s passed to <code>func</code> is the length of the smaller of the two nodes’ collections of children.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> U ZipFold<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;(</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span> T value1<span class="op">,</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    T value2</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    Func<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">,</span> IEnumerable<span class="op">&lt;</span>U<span class="op">&gt;,</span> U<span class="op">&gt;</span> zipFunc</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> where T <span class="op">:</span> IRewritable<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="fu">zipFunc</span><span class="op">(</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>        value1<span class="op">,</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        value2<span class="op">,</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>        value1<span class="op">.</span><span class="fu">GetChildren</span><span class="op">().</span><span class="fu">Zip</span><span class="op">(</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>            value2<span class="op">.</span><span class="fu">GetChildren</span><span class="op">(),</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>child1<span class="op">,</span> child2<span class="op">)</span> <span class="op">=&gt;</span> child1<span class="op">.</span><span class="fu">ZipFold</span><span class="op">(</span>child2<span class="op">,</span> zipFunc<span class="op">)</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span></code></pre></div><p>The two trees are zipped together and torn down in a single pass.</p>
<p>Here’s how it looks in Haskell, using the <a href="https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html"><code>Control.Lens.Plated</code></a> API. Haskellers like to use tongue-in-cheek Greek names for recursion schemes. Apparently the Greek word for “zip” is “fermouár”, so I’m calling this a <em>fermomorphism</em>.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">fermo ::</span> <span class="dt">Plated</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>fermo f x y <span class="ot">=</span> f x y <span class="op">$</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">zipWith</span> (fermo f) (toListOf plate x) (toListOf plate y)</span></code></pre></div><p>As an example: <code>ZipFold</code> allows you to concisely test a pair of trees for equality, by looking only at one pair of nodes at a time.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="dt">bool</span> <span class="fu">Equal</span><span class="op">(</span>JqlNode j1<span class="op">,</span> JqlNode j2<span class="op">)</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> j1<span class="op">.</span><span class="fu">ZipFold</span><span class="op">&lt;</span>JqlNode<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;(</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        j2<span class="op">,</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>n1<span class="op">,</span> n2<span class="op">,</span> childrenEqual<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">switch</span> <span class="op">(</span>n1<span class="op">)</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> SalaryNode s1 when n2 <span class="kw">is</span> SalaryNode s2<span class="op">:</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> s1<span class="op">.</span><span class="fu">Currency</span> <span class="op">==</span> s2<span class="op">.</span><span class="fu">Currency</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>                        <span class="op">&amp;&amp;</span> s1<span class="op">.</span><span class="fu">Amount</span> <span class="op">==</span> s2<span class="op">.</span><span class="fu">Amount</span><span class="op">;</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> TagNode t1 when n2 <span class="kw">is</span> TagNode t2<span class="op">:</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> t1<span class="op">.</span><span class="fu">Tag</span> <span class="op">==</span> t2<span class="op">.</span><span class="fu">Tag</span><span class="op">;</span></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> AndNode a1 when n2 <span class="kw">is</span> AndNode a2<span class="op">:</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> OrNode o1 when n2 <span class="kw">is</span> OrNode o2<span class="op">:</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> NotNode a1 when n2 <span class="kw">is</span> NotNode a2<span class="op">:</span></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> childrenEqual<span class="op">.</span><span class="fu">All</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">);</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>                <span class="kw">default</span><span class="op">:</span></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="21"><a href="#21" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span></code></pre></div><p>The <code>ZipFold</code> that you’ll find in Sawmill is actually an <em>n</em>-ary zip-fold. Instead of taking two <code>T</code>s, and passing two <code>T</code>s to <code>func</code>, it works with an arbitrary number of <code>T</code>s. Here’s the code:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> U ZipFold<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;(</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span> T<span class="op">[]</span> values<span class="op">,</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    Func<span class="op">&lt;</span>T<span class="op">[],</span> IEnumerable<span class="op">&lt;</span>U<span class="op">&gt;,</span> U<span class="op">&gt;</span> func</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> where T <span class="op">:</span> IRewritable<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="fu">func</span><span class="op">(</span>values<span class="op">,</span> xs<span class="op">.</span><span class="fu">ZipChildren</span><span class="op">(</span>children <span class="op">=&gt;</span> children<span class="op">.</span><span class="fu">ZipFold</span><span class="op">(</span>func<span class="op">)));</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="kw">static</span> IEnumerable<span class="op">&lt;</span>U<span class="op">&gt;</span> ZipChildren<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;(</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span> T<span class="op">[]</span> input<span class="op">,</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>    Func<span class="op">&lt;</span>T<span class="op">[],</span> U<span class="op">&gt;</span> zipFunc</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> where T <span class="op">:</span> IRewritable<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> enumerators <span class="op">=</span> input</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">Select</span><span class="op">(</span>x <span class="op">=&gt;</span> x<span class="op">.</span><span class="fu">GetChildren</span><span class="op">().</span><span class="fu">GetEnumerator</span><span class="op">())</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">ToArray</span><span class="op">();</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> <span class="op">(</span>enumerators<span class="op">.</span><span class="fu">All</span><span class="op">(</span>e <span class="op">=&gt;</span> e<span class="op">.</span><span class="fu">MoveNext</span><span class="op">()))</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">yield</span> <span class="kw">return</span> <span class="fu">zipFunc</span><span class="op">(</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>            enumerators<span class="op">.</span><span class="fu">Select</span><span class="op">(</span>e <span class="op">=&gt;</span> e<span class="op">.</span><span class="fu">Current</span><span class="op">).</span><span class="fu">ToArray</span><span class="op">()</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="21"><a href="#21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="22"><a href="#22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>Sadly, the invariant that <code>zipFunc</code> receives the same number of <code>T</code>s as were passed to <code>ZipFold</code> is not expressible in C#’s type system. So as a consumer of <code>ZipFold</code>, you just have to trust that <code>zipFunc</code>’s argument is of a certain size. In the <code>Equal</code> example, that size is two, because we’re consuming two trees:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="dt">bool</span> <span class="fu">Equal</span><span class="op">(</span>JqlNode j1<span class="op">,</span> JqlNode j2<span class="op">)</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> <span class="kw">new</span><span class="op">[]</span> <span class="op">{</span> j1<span class="op">,</span> j2 <span class="op">}.</span><span class="fu">ZipFold</span><span class="op">&lt;</span>JqlNode<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;(</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>ns<span class="op">,</span> childrenEqual<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">switch</span> <span class="op">(</span>ns<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> SalaryNode s1 when ns<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="kw">is</span> SalaryNode s2<span class="op">:</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> s1<span class="op">.</span><span class="fu">Currency</span> <span class="op">==</span> s2<span class="op">.</span><span class="fu">Currency</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>                        <span class="op">&amp;&amp;</span> s1<span class="op">.</span><span class="fu">Amount</span> <span class="op">==</span> s2<span class="op">.</span><span class="fu">Amount</span><span class="op">;</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> TagNode t1 when ns<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="kw">is</span> TagNode t2<span class="op">:</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> t1<span class="op">.</span><span class="fu">Tag</span> <span class="op">==</span> t2<span class="op">.</span><span class="fu">Tag</span><span class="op">;</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> AndNode a1 when ns<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="kw">is</span> AndNode a2<span class="op">:</span></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> OrNode o1 when ns<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="kw">is</span> OrNode o2<span class="op">:</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> NotNode n1 when ns<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="kw">is</span> NotNode n2<span class="op">:</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> childrenEqual<span class="op">.</span><span class="fu">All</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">);</span></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>                <span class="kw">default</span><span class="op">:</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span></code></pre></div><p>Here’s the Haskell transliteration of this <em>n</em>-ary zip-fold function, which <code>traverse</code>s in the <code>ZipList</code> <code>Applicative</code> to concisely zip <em>n</em> lists of children:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">fermo ::</span> <span class="dt">Plated</span> a <span class="ot">=&gt;</span> ([a] <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> r</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>fermo f xs <span class="ot">=</span> f xs (</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">map</span> (fermo f) <span class="op">$</span> getZipList <span class="op">$</span> <span class="fu">traverse</span> (<span class="dt">ZipList</span> <span class="op">.</span> toListOf plate) xs</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div><p><code>ZipFold</code> is available in <a href="https://www.nuget.org/packages/Sawmill/">version 1.3.0 of Sawmill</a>.</p>


        </article>

        <footer id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
