<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>benjamin.pizza - Functor Functors</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>

        <script async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../" id="logo"><pre>benjamin.pizza</pre></a>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
                <a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a>
            </div>
        </div>

        <div id="content">
            <header>
                <h1>Functor Functors</h1>
                
            </header>

            <div class="info">
    Posted on December 15, 2017
    
</div>

<p>You can teach a new dog old tricks.</p>
<p>One of the fun things about category theory is that once you’ve learned an idea in one context it’s easy to apply it to another one. Of the numerous categories available to Haskell programmers, <strong>Hask</strong>, the category of Haskell types and functions, gets the lion’s share of the attention. Working with standard abstractions in more overlooked categories is a great way to reuse ideas: it makes you look clever, like you’ve invented something new, but actually all you’ve done is put the building blocks together differently. I won’t tell if you don’t.</p>
<h2 id="templates-reusable-records">Templates: Reusable Records</h2>
<p>Every now and then I’ll see a question on Stack Overflow or Reddit in which a programmer is trying to work with a bunch of record types which share a similar structure. For a contrived example, in a shopping system you may want to differentiate between completed checkout forms, which are ready to be dispatched, and “draft” checkout forms, which the user is currently filling in. The simplest way to do this is to build separate types, and write a function to upgrade a draft form to a regular form if all of its fields are filled in.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CardType</span> <span class="fu">=</span> <span class="dt">Visa</span> <span class="fu">|</span> <span class="dt">AmEx</span> <span class="fu">|</span> <span class="dt">Mastercard</span>

<span class="kw">data</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">Form</span> {
<span class="ot">    form_email ::</span> <span class="dt">Text</span>,
<span class="ot">    form_cardType ::</span> <span class="dt">CardType</span>,
<span class="ot">    form_cardNumber ::</span> <span class="dt">Text</span>,
<span class="ot">    form_cardExpiry ::</span> <span class="dt">Day</span>
}

<span class="kw">data</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">DraftForm</span> {
<span class="ot">    draftForm_email ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>,
<span class="ot">    draftForm_cardType ::</span> <span class="dt">Maybe</span> <span class="dt">CardType</span>,
<span class="ot">    draftForm_cardNumber ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>,
<span class="ot">    draftForm_cardExpiry ::</span> <span class="dt">Maybe</span> <span class="dt">Day</span>
}

<span class="ot">toForm ::</span> <span class="dt">DraftForm</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Form</span>
toForm (<span class="dt">DraftForm</span>
    (<span class="dt">Just</span> email)
    (<span class="dt">Just</span> cardType)
    (<span class="dt">Just</span> cardNumber)
    (<span class="dt">Just</span> cardExpiry)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
        <span class="dt">Form</span> email cardType cardNumber cardExpiry
toForm _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>Now, the standard trick to de-duplicate these two types is to derive both from what I’ll call a <em>template</em> type, wrapping each field of the template in some type constructor <code>f</code>. You recover <code>Form</code> by setting <code>f</code> to the boring <code>Identity</code> functor, and you get <code>DraftForm</code> by setting <code>f</code> to <code>Maybe</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FormTemplate</span> f <span class="fu">=</span> <span class="dt">FormTemplate</span> {
<span class="ot">    _email ::</span> f <span class="dt">Text</span>,
<span class="ot">    _cardType ::</span> f <span class="dt">CardType</span>,
<span class="ot">    _cardNumber ::</span> f <span class="dt">Text</span>,
<span class="ot">    _cardExpiry ::</span> f <span class="dt">Day</span>
}
<span class="kw">type</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="dt">Identity</span>
<span class="kw">type</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="dt">Maybe</span></code></pre></div>
<p>So a template is a record type parameterised by a type constructor. It’ll generally have a kind of <code>(* -&gt; *) -&gt; *</code>. The fields of the record are the type constructor applied to a variety of different type arguments. Working with a template typically involves coming up with an interesting type constructor <code>(* -&gt; *)</code> and plugging it in to get interestingly-typed fields. You can think of a record as a container of <code>f</code>s.</p>
<p>This trick has become Haskell folklore - I couldn’t tell you where I first saw it - but I’ve only seen a few people talk about what happens when you treat templates as first class citizens. To get used to this style, a simple example is giving names to specific instantiations of arbitrary templates:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Record</span> t <span class="fu">=</span> t <span class="dt">Identity</span>
<span class="kw">type</span> <span class="dt">Partial</span> t <span class="fu">=</span> t <span class="dt">Maybe</span>

<span class="kw">type</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">FormTemplate</span>
<span class="kw">type</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">Partial</span> <span class="dt">FormTemplate</span></code></pre></div>
<p>The rest of this blog post is about treating template types intuitively as fixed-size containers of functors. I’ll be taking familiar tools for working with containers of <em>values</em> - <code>Functor</code>, <code>Traversable</code>, <code>Representable</code> - and applying them to the context of containers of <em>functors</em>.</p>
<h2 id="functors-from-the-category-of-endofunctors">Functors from the Category of Endofunctors</h2>
<p>In Haskell, categories are represented as a <em>kind</em> <code>k</code> of objects and a <em>type constructor</em> <code>c :: k -&gt; k -&gt; *</code> of morphisms between those objects. If the category <code>C</code> has objects in <code>k1</code> and morphisms in <code>c</code>, and <code>D</code> has objects in <code>k2</code> and morphisms in <code>d</code>, then a functor from <code>C</code> to <code>D</code> is a type constructor <code>f :: k1 -&gt; k2</code> mapping objects paired with an operation <code>fmap :: c a b -&gt; d (f a) (f b)</code> mapping the morphisms. The standard <code>Functor</code> class is for <em>endofunctors on <strong>Hask</strong></em> - the special case in which <code>k1 ~ k2 ~ *</code> and <code>c ~ d ~ (-&gt;)</code>.</p>
<p><img src="../images/2017-12-15-functor-functors/hask.jpg" alt="Endofunctors on Hask" width="700" /></p>
<p>Given two categories <code>C</code> and <code>D</code>, you can construct the category of functors between <code>C</code> and <code>D</code>, written as <code>[C, D]</code>. Objects in this category are functors from <code>C</code> to <code>D</code>, and morphisms are natural transformations between those functors. Since <code>[C, D]</code> is a regular category, you can of course have functors mapping that category to other categories. So in Haskell that’d be a type of kind <code>(k1 -&gt; k2) -&gt; k3</code>. I’ll call such types <em>functor functors</em>.</p>
<p>We’re talking about record templates of kind <code>(* -&gt; *) -&gt; *</code>. This fits the pattern of a functor from the functor category, with <code>k1 ~ k2 ~ k3 ~ *</code>. So the functor category in question is the category of endofunctors on <strong>Hask</strong> (that is, members of the standard <code>Functor</code> class), and the destination category is <strong>Hask</strong>. So it’s reasonable to expect record templates to be functorial in their argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- natural transformations between functors f and g</span>
<span class="kw">type</span> f <span class="fu">~&gt;</span> g <span class="fu">=</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x

<span class="co">-- &quot;functor functors&quot;, functors from the functor category</span>
<span class="kw">class</span> <span class="dt">FFunctor</span> f <span class="kw">where</span>
<span class="ot">    ffmap ::</span> (<span class="dt">Functor</span> g, <span class="dt">Functor</span> h) <span class="ot">=&gt;</span> (g <span class="fu">~&gt;</span> h) <span class="ot">-&gt;</span> f g <span class="ot">-&gt;</span> f h

<span class="kw">instance</span> <span class="dt">FFunctor</span> <span class="dt">FormTemplate</span> <span class="kw">where</span>
    ffmap eta (<span class="dt">FormTemplate</span> email cardType cardNumber cardExpiry)
        <span class="fu">=</span> <span class="dt">FormTemplate</span>
            (eta email)
            (eta cardType)
            (eta cardNumber)
            (eta cardExpiry)</code></pre></div>
<p><code>FFunctor</code> comes with the usual functor laws. The only difference is the types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- identity</span>
ffmap id <span class="fu">=</span> id

<span class="co">-- composition</span>
ffmap (eta <span class="fu">.</span> phi) <span class="fu">=</span> ffmap eta <span class="fu">.</span> ffmap phi</code></pre></div>
<p><img src="../images/2017-12-15-functor-functors/ffunctor.jpg" alt="Functor functors" width="700" /></p>
<p><code>ffmap</code> encodes the notion of generalising the functor a template has been instantiated with. If you can embed the functor <code>f</code> into <code>g</code>, then you can map a record of <code>f</code>s to a record of <code>g</code>s by embedding each <code>f</code>. (This is also sometimes called “hoisting”.) For example, the boring <code>Identity</code> functor can be embedded into an arbitrary <code>Applicative</code> by injecting the contained value using <code>pure</code>. We can use this to turn a total record into a partial one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generalise ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> f a
generalise (<span class="dt">Identity</span> x) <span class="fu">=</span> pure x

<span class="ot">toPartial ::</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Partial</span> t
toPartial <span class="fu">=</span> ffmap generalise</code></pre></div>
<h2 id="traversing-records">Traversing Records</h2>
<p>Now that we have a new dog, it’s natural to ask which old tricks we can teach it. With the intuition that a template <code>t f</code> is like a container of <code>f</code>s, what does it mean to traverse such a container? <code>sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)</code> takes a container of strategies to produce values and sequences them to get a strategy to produce a container of values. Replacing <em>value</em> with <em>functor</em> in the above sentence, it’s clear that we need to decide on a notion of “strategy to produce a functor”. <a href="https://stackoverflow.com/questions/44187945/what-should-a-higher-order-traversable-class-look-like">With thanks to Li-yao Xia</a>, the simplest of such notions is a regular applicative functor <code>a</code> returning a functorial value <code>g x</code> - that is, <code>Compose a g</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FTraversable</span> t <span class="kw">where</span>
<span class="ot">    ftraverse ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Applicative</span> a)
              <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> <span class="dt">Compose</span> a g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> a (t g)
    ftraverse eta <span class="fu">=</span> fsequence <span class="fu">.</span> ffmap eta
<span class="ot">    fsequence ::</span> (<span class="dt">Functor</span> f, <span class="dt">Applicative</span> a)
              <span class="ot">=&gt;</span> t (<span class="dt">Compose</span> a f) <span class="ot">-&gt;</span> a (t f)
    fsequence <span class="fu">=</span> ftraverse id

<span class="ot">ffmapDefault ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">FTraversable</span> t)
             <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g
ffmapDefault eta <span class="fu">=</span>
    runIdentity <span class="fu">.</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">.</span> eta)

<span class="ot">fsequence' ::</span> (<span class="dt">FTraversable</span> t, <span class="dt">Applicative</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a (<span class="dt">Record</span> t)
fsequence' <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> fmap <span class="dt">Identity</span>)</code></pre></div>
<p>The <code>FTraversable</code> laws come about by adjusting the <code>Traversable</code> laws to add some <code>Compose</code>-bookkeeping.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- naturality</span>
nu <span class="fu">.</span> ftraverse eta <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> nu <span class="fu">.</span> getCompose <span class="fu">.</span> eta)
<span class="co">-- for any applicative transformation nu</span>

<span class="co">-- identity</span>
ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Identity</span>) <span class="fu">=</span> <span class="dt">Identity</span>

<span class="co">-- composition</span>
ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Compose</span> <span class="fu">.</span> fmap (getCompose<span class="fu">.</span>phi) <span class="fu">.</span> getCompose <span class="fu">.</span> eta)
    <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">.</span> fmap (ftraverse phi) <span class="fu">.</span> ftraverse eta</code></pre></div>
<p>Implementations of <code>traverse</code> look like implementations of <code>fmap</code> but in an applicative context. Likewise, implementations of <code>ftraverse</code> look like implementations of <code>ffmap</code> in an applicative context, with a few <code>getCompose</code>s scattered around.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FTraversable</span> <span class="dt">FormTemplate</span> <span class="kw">where</span>
    ftraverse eta (<span class="dt">FormTemplate</span> email cardType cardNumber cardExpiry)
        <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="fu">&lt;$&gt;</span>
            (getCompose <span class="fu">$</span> eta email) <span class="fu">&lt;*&gt;</span>
            (getCompose <span class="fu">$</span> eta cardType) <span class="fu">&lt;*&gt;</span>
            (getCompose <span class="fu">$</span> eta cardNumber) <span class="fu">&lt;*&gt;</span>
            (getCompose <span class="fu">$</span> eta cardExpiry)</code></pre></div>
<p>This is where things start to get interesting. The <code>toForm</code> function, which converts a draft form to a regular form if all of its fields have been filled in, can be defined tersely in terms of <code>ftraverse</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toRecord ::</span> <span class="dt">FTraversable</span> t <span class="ot">=&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Record</span> t)
toRecord <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> fmap <span class="dt">Identity</span>)

<span class="ot">toForm ::</span> <span class="dt">DraftForm</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Form</span>
toForm <span class="fu">=</span> toRecord</code></pre></div>
<p>Here’s another example: a generic program, defined by analogy to <code>Foldable</code>’s <code>foldMap</code>, to collapse the fields of a record into a monoidal value. Note that <code>f () -&gt; m</code> is isomorphic to, but simpler than, <code>forall x. f x -&gt; m</code>. Annoyingly, we have to give a type signature to <code>mkConst</code> to resolve the ambiguity over <code>g</code> in the call to <code>ftraverse</code>. I’m picking <code>Empty</code> as a way of demonstrating that I have nothing up my sleeves.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Empty</span> a <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="ot">ffoldMap ::</span> forall f t m<span class="fu">.</span> (<span class="dt">Monoid</span> m, <span class="dt">Functor</span> f, <span class="dt">FTraversable</span> t)
         <span class="ot">=&gt;</span> (f () <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> m
ffoldMap f <span class="fu">=</span> getConst <span class="fu">.</span> ftraverse mkConst
    <span class="kw">where</span>
        <span class="co">-- using ScopedTypeVariables to bind f</span>
<span class="ot">        mkConst ::</span> f x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Const</span> m) <span class="dt">Empty</span> x
        mkConst <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> f <span class="fu">.</span> (<span class="fu">$&gt;</span> ())</code></pre></div>
<h2 id="zipping-templates">Zipping templates</h2>
<p>Given a pair of records of the same shape <code>t</code>, we should be able to combine them point-wise, matching up the fields of each: <code>fzip :: t f -&gt; t g -&gt; t (Product f g)</code>. In <strong>Hask</strong>, “combining point-wise” is exactly what the “reader” applicative <code>(-&gt;) r</code> does, so any functor which enjoys an isomorphism to <code>(-&gt;) r</code> for some <code>r</code> has at least a zippy <code>Applicative</code> instance. Such functors are called <em>representable functors</em> and they are members of the class <a href="https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html#t:Representable"><code>Representable</code></a>.</p>
<p>Of course, we’re working with functors from the functor category, so the relevant notion of <code>Representable</code> will need a little adjustment. Instead of an isomorphism to a function <code>(-&gt;) r</code> we’ll use an isomorphism to a natural transformation <code>(~&gt;) r</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FRepresentable</span> t <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">FRep</span><span class="ot"> t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">    ftabulate ::</span> (<span class="dt">FRep</span> t <span class="fu">~&gt;</span> f) <span class="ot">-&gt;</span> t f
<span class="ot">    findex ::</span> t f <span class="ot">-&gt;</span> <span class="dt">FRep</span> t a <span class="ot">-&gt;</span> f a

<span class="ot">fzipWith ::</span> <span class="dt">FRepresentable</span> t
         <span class="ot">=&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x <span class="ot">-&gt;</span> h x)
         <span class="ot">-&gt;</span>            t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t h
fzipWith f t u <span class="fu">=</span> ftabulate <span class="fu">$</span> \r <span class="ot">-&gt;</span> f (findex t r) (findex u r)

<span class="ot">fzipWith3 ::</span> <span class="dt">FRepresentable</span> t
          <span class="ot">=&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x <span class="ot">-&gt;</span> h x <span class="ot">-&gt;</span> k x)
          <span class="ot">-&gt;</span>            t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t h <span class="ot">-&gt;</span> t k
fzipWith3 f t u v <span class="fu">=</span> ftabulate <span class="fu">$</span>
    \r <span class="ot">-&gt;</span> f (findex t r) (findex u r) (findex v r)

<span class="ot">fzip ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t (<span class="dt">Product</span> f g)
fzip <span class="fu">=</span> fzipWith <span class="dt">Pair</span></code></pre></div>
<p>The laws for <code>FRepresentable</code> simply state that <code>ftabulate</code> and <code>findex</code> must witness an isomorphism:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- isomorphism</span>
ftabulate <span class="fu">.</span> findex <span class="fu">=</span> findex <span class="fu">.</span> ftabulate <span class="fu">=</span> id</code></pre></div>
<p><code>FRep</code> will typically be a GADT: it tells you what type of value one should expect to find at a given position in a record.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FormTemplateRep</span> a <span class="kw">where</span>
    <span class="dt">Email</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Text</span>
    <span class="dt">CardType</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">CardType</span>
    <span class="dt">CardNumber</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Text</span>
    <span class="dt">CardExpiry</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Day</span>

<span class="kw">instance</span> <span class="dt">FRepresentable</span> <span class="dt">FormTemplate</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">FRep</span> <span class="dt">FormTemplate</span> <span class="fu">=</span> <span class="dt">FormTemplateRep</span>

    ftabulate eta <span class="fu">=</span> <span class="dt">FormTemplate</span>
        (eta <span class="dt">Email</span>)
        (eta <span class="dt">CardType</span>)
        (eta <span class="dt">CardNumber</span>)
        (eta <span class="dt">CardExpiry</span>)
    
    findex p <span class="dt">Email</span> <span class="fu">=</span> _email p
    findex p <span class="dt">CardType</span> <span class="fu">=</span> _cardType p
    findex p <span class="dt">CardNumber</span> <span class="fu">=</span> _cardNumber p
    findex p <span class="dt">CardExpiry</span> <span class="fu">=</span> _cardExpiry p</code></pre></div>
<p>Something useful you can do with this infrastructure: filling in defaults for missing values of a partial record. Or, looking at it the other way, overriding certain parts of a record.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">with ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t
with <span class="fu">=</span> fzipWith override
    <span class="kw">where</span> override x <span class="dt">Nothing</span> <span class="fu">=</span> x
          override _ (<span class="dt">Just</span> y) <span class="fu">=</span> <span class="dt">Identity</span> y

<span class="ot">fillInDefaults ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t
fillInDefaults t defaults <span class="fu">=</span> defaults <span class="ot">`with`</span> t</code></pre></div>
<p>You can also make a record of <code>Monoid</code> values into a <code>Monoid</code>, once again by zipping.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Wrap</span> t f <span class="fu">=</span> <span class="dt">Wrap</span> {<span class="ot"> unWrap ::</span> t f }
makeWrapped <span class="ch">''</span><span class="dt">Wrap</span>  <span class="co">-- from Control.Lens.Wrapped</span>

<span class="kw">instance</span> (<span class="dt">FRepresentable</span> t, <span class="dt">Monoid</span> c) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Wrap</span> t (<span class="dt">Const</span> c)) <span class="kw">where</span>
    mempty <span class="fu">=</span> <span class="dt">Wrap</span> <span class="fu">$</span> ftabulate (const (<span class="dt">Const</span> mempty))
    <span class="dt">Wrap</span> t <span class="ot">`mappend`</span> <span class="dt">Wrap</span> u <span class="fu">=</span> <span class="dt">Wrap</span> <span class="fu">$</span> fzipWith mappend t u</code></pre></div>
<h2 id="lenses">Lenses</h2>
<p>Rather than come up with a new notion of <code>Lens</code> formulated in terms of <code>FFunctor</code>, we can reuse the standard <code>Lens</code> type as long as we’re careful about how polymorphic lenses should be. Specifically, a lens into a record template should express no opinion as to which functor the template should be instantiated with.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FLens</span> t a <span class="fu">=</span> <span class="dt">FLens</span> (forall f<span class="fu">.</span> <span class="dt">Lens'</span> (t f) (f a))</code></pre></div>
<p>We can store a template’s lenses in an instance of the template itself!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Lenses</span> t <span class="fu">=</span> t (<span class="dt">FLens</span> t)

<span class="kw">class</span> <span class="dt">HasLenses</span> t <span class="kw">where</span>
<span class="ot">    lenses ::</span> <span class="dt">Lenses</span> t

makeLenses <span class="ch">''</span><span class="dt">FormTemplate</span>
<span class="kw">instance</span> <span class="dt">HasLenses</span> <span class="dt">FormTemplate</span> <span class="kw">where</span>
    lenses <span class="fu">=</span> <span class="dt">FormTemplate</span> {
        _email <span class="fu">=</span> <span class="dt">FLens</span> email,
        _cardType <span class="fu">=</span> <span class="dt">FLens</span> cardType,
        _cardNumber <span class="fu">=</span> <span class="dt">FLens</span> cardNumber,
        _cardExpiry <span class="fu">=</span> <span class="dt">FLens</span> cardExpiry
    }</code></pre></div>
<h2 id="compositional-validation">Compositional Validation</h2>
<p>Now for an extended example: form validation. We’ll be making use of all of the tools from above - zipping, traversing, and mapping - to design a typed API for validating individual fields of a form.</p>
<p><code>Either</code> isn’t a great choice for a validation monad, because <code>Either</code> aborts the computation at the first failure. You typically want to report all the errors in a form. Instead, we’ll be working with the following type, which is isomorphic to <code>Either</code> but with an <code>Applicative</code> instance which returns <em>all</em> of the failures in a given computation, combining the values using a <code>Monoid</code>. So it’s kind of a Frankensteinian mishmash of the <code>Either</code> and <code>Writer</code> applicatives.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Validation</span> e a <span class="fu">=</span> <span class="dt">Failure</span> e <span class="fu">|</span> <span class="dt">Success</span> a <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Validation</span> <span class="kw">where</span>
    bimap f g (<span class="dt">Failure</span> e) <span class="fu">=</span> <span class="dt">Failure</span> (f e)
    bimap f g (<span class="dt">Success</span> x) <span class="fu">=</span> <span class="dt">Success</span> (g x)

<span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Validation</span> e) <span class="kw">where</span>
    pure <span class="fu">=</span> <span class="dt">Success</span>
    <span class="dt">Success</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Success</span> x <span class="fu">=</span> <span class="dt">Success</span> (f x)
    <span class="dt">Failure</span> e1 <span class="fu">&lt;*&gt;</span> <span class="dt">Failure</span> e2 <span class="fu">=</span> <span class="dt">Failure</span> (e1 <span class="ot">`mappend`</span> e2)
    <span class="dt">Failure</span> e1 <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Failure</span> e1
    _ <span class="fu">&lt;*&gt;</span> <span class="dt">Failure</span> e2 <span class="fu">=</span> <span class="dt">Failure</span> e2</code></pre></div>
<p>This <code>Applicative</code> instance has no compatible <code>Monad</code> instance.</p>
<p>We’ll build a library for validation processes which examine a single field of a record at a time. A validation rule for a field typed <code>a</code> is a function which takes an <code>a</code> and returns a <code>Validation e a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Validator</span> e a <span class="fu">=</span> <span class="dt">Validator</span> {<span class="ot"> runValidator ::</span> a <span class="ot">-&gt;</span> <span class="dt">Validation</span> e a }

<span class="co">-- a validator which always succeeds</span>
<span class="ot">noop ::</span> <span class="dt">Validator</span> e a
noop <span class="fu">=</span> <span class="dt">Validator</span> <span class="dt">Success</span></code></pre></div>
<p>If a given field has multiple validation rules, you can compose them under the assumption that each validator leaves its input unchanged.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;&gt;) ::</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Validator</span> e a <span class="ot">-&gt;</span> <span class="dt">Validator</span> e a <span class="ot">-&gt;</span> <span class="dt">Validator</span> e a
<span class="dt">Validator</span> f <span class="fu">&amp;&gt;</span> <span class="dt">Validator</span> g <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> f x <span class="fu">*&gt;</span> g x

<span class="co">-- for example</span>
<span class="ot">emailValidator ::</span> <span class="dt">Validator</span> [<span class="dt">Text</span>] <span class="dt">Text</span>
emailValidator <span class="fu">=</span> hasAtSymbol <span class="fu">&amp;&gt;</span> hasTopLevelDomain
    <span class="kw">where</span>
        hasAtSymbol <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \email <span class="ot">-&gt;</span> 
            <span class="kw">if</span> <span class="st">&quot;@&quot;</span> <span class="ot">`isInfixOf`</span> email
            <span class="kw">then</span> <span class="dt">Success</span> email
            <span class="kw">else</span> <span class="dt">Failure</span> [<span class="st">&quot;No @ in email&quot;</span>]
        hasTopLevelDomain <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \email <span class="ot">-&gt;</span>
            <span class="kw">if</span> any (<span class="ot">`isSuffixOf`</span> email) topLevelDomains
            <span class="kw">then</span> <span class="dt">Success</span> email
            <span class="kw">else</span> <span class="dt">Failure</span> [<span class="st">&quot;Invalid TLD&quot;</span>]
        topLevelDomains <span class="fu">=</span> [<span class="st">&quot;.com&quot;</span>, <span class="st">&quot;.org&quot;</span>, <span class="st">&quot;.co.uk&quot;</span>]  <span class="co">-- etc</span></code></pre></div>
<p>The plan is to store these <code>Validator</code>s in a record template, zip them along an instance of the record itself, and then traverse the result to get either a validated record or a collection of errors. To make things interesting, we’ll store the validation results for a given field in the matching field of another record.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Validators</span> e t <span class="fu">=</span> t (<span class="dt">Validator</span> e)
<span class="kw">type</span> <span class="dt">Errors</span> e t <span class="fu">=</span> t (<span class="dt">Const</span> e)

<span class="co">-- turn a record of validators into a validator of records</span>
<span class="ot">validate ::</span> (<span class="dt">HasLenses</span> t, <span class="dt">FTraversable</span> t, <span class="dt">FRepresentable</span> t, <span class="dt">Monoid</span> e)
         <span class="ot">=&gt;</span> <span class="dt">Validators</span> e t
         <span class="ot">-&gt;</span> <span class="dt">Validator</span> (<span class="dt">Errors</span> e t) (<span class="dt">Record</span> t)
validate validators <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \record <span class="ot">-&gt;</span>
    first unWrap <span class="fu">$</span>
    fsequence' <span class="fu">$</span>
    fzipWith3 applyValidator lenses validators record
    <span class="kw">where</span>
        applyValidator
            (<span class="dt">FLens</span> lens)
            (<span class="dt">Validator</span> validator)
            (<span class="dt">Identity</span> value) <span class="fu">=</span>
                <span class="kw">let</span> setError e <span class="fu">=</span> mempty <span class="fu">&amp;</span> _Wrapped'<span class="fu">.</span>lens<span class="fu">.</span>_Wrapped' <span class="fu">.~</span> e
                <span class="kw">in</span> first setError <span class="fu">$</span> validator value</code></pre></div>
<p><code>applyValidator</code> takes a lens into a record field, a validator for that field and the value in that field. It applies the validator to the value; upon failure it stores the error message (<code>e</code>) in the correct field of the <code>Errors</code> record using the lens. <code>fzipWith3</code> handles the logic of running <code>applyValidator</code> for each field of the record, then <code>fsequence'</code> combines the resulting <code>Validation</code> applicative actions into a single one. So all of the errors from all of the fields are eventually collected into the matching fields of the <code>Errors</code> record and combined monoidally.</p>
<p>A quick test, wherein I test validation on the email field:</p>
<pre><code>ghci&gt; let formValidator = validate
    $ FormTemplate emailValidator noop noop noop
ghci&gt; let today = read &quot;2017-08-17&quot; :: Day

ghci&gt; let form1 = FormTemplate
    (Identity &quot;bhodgson@stackoverflow.com&quot;)
    (Identity Visa)
    (Identity &quot;1234567890123456&quot;)
    (Identity today)
ghci&gt; runValidator formValidator form1
Success (FormTemplate {
    _email = Identity &quot;bhodgson@stackoverflow.com&quot;,
    _cardType = Identity Visa,
    _cardNumber = Identity &quot;1234567890123456&quot;,
    _cardExpiry = Identity 2017-08-17
    })

ghci&gt; let form2 = FormTemplate
    (Identity &quot;notanemail&quot;)
    (Identity Visa)
    (Identity &quot;1234567890123456&quot;)
    (Identity today)
ghci&gt; runValidator formValidator form2
Failure (FormTemplate {
    _email = Const [&quot;No @ in email&quot;,&quot;Invalid TLD&quot;],
    _cardType = Const [],
    _cardNumber = Const [],
    _cardExpiry = Const []
    })</code></pre>
<h2 id="code-review">Code review</h2>
<p>So we have a categorical framework for working with records and templates. Other things fit into this framework, more or less neatly:</p>
<ul>
<li>Monad transformers are often functorial in their <code>m</code> argument.</li>
<li><code>Fix f</code> (a “list of <code>f</code>s”, if you will) is also a functor functor, where <code>ffmap</code>ping represents a change of variables.</li>
<li>Since the <code>Const</code>, <code>Sum</code>, <code>Product</code> and <code>Compose</code> type combinators are poly-kinded, they can be reused as functor functors too.</li>
<li>Add another primitive <code>FFunctor</code> to apply a functor to a type, <code>newtype At a f = At { getAt :: f a }</code>, and you have a kit to build polynomial functor functors with which you can build templates and write generic programs.</li>
</ul>
<p>One design decision I made when developing the <code>FFunctor</code> class was to give <code>ffmap</code> a <code>(Functor f, Functor g)</code> constraint, so you can only <code>ffmap</code> between types that are in fact functors. This is mathematically principled in some sense, but it has certain engineering tradeoffs compared to an unconstrained type for <code>ffmap</code>. It enables more instances of <code>FFunctor</code> - for example, you can only write <code>Fix</code>’s <code>ffmap</code> with a <code>Functor</code> constraint for either the input or output type parameters - but it rules out certain usages of <code>ffmap</code>. You can’t <code>ffmap</code> over a template containing <code>Validator</code>s, for example, because <code>Validator</code> is not a <code>Functor</code>. I <em>didn’t</em> put the same <code>Functor</code> constraints into <code>FRepresentable</code>’s methods. An <code>FRep</code> type typically won’t be functorial - it’ll be GADT-like - so adding a <code>Functor (FRep t)</code> constraint would be far too restrictive.</p>
<p>You’ll notice that the concept of an applicative functor functor is conspicuously absent from my presentation above. <code>FApplicative</code> would probably look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> (f <span class="fu">:-&gt;</span> g) a <span class="fu">=</span> <span class="dt">Morph</span> {<span class="ot"> getMorph ::</span> f a <span class="ot">-&gt;</span> g a }

<span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FApplicative</span> t <span class="kw">where</span>
<span class="ot">    fpure ::</span> (forall a<span class="fu">.</span> f a) <span class="ot">-&gt;</span> t f
<span class="ot">    fap ::</span> t (f <span class="fu">:-&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g

<span class="ot">fliftA ::</span> <span class="dt">FApplicative</span> t <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g
fliftA eta t <span class="fu">=</span> fpure (<span class="dt">Morph</span> eta) <span class="ot">`fap`</span> t

<span class="kw">instance</span> <span class="dt">FApplicative</span> <span class="dt">FormTemplate</span> <span class="kw">where</span>
    fpure x <span class="fu">=</span> <span class="dt">FormTemplate</span> x x x x
    fap
        (<span class="dt">FormTemplate</span>
            (<span class="dt">Morph</span> f1)
            (<span class="dt">Morph</span> f2)
            (<span class="dt">Morph</span> f3)
            (<span class="dt">Morph</span> f4))
        (<span class="dt">FormTemplate</span>
            email
            cardType
            cardNumber
            cardExpiry)
        <span class="fu">=</span> <span class="dt">FormTemplate</span>
            (f1 email)
            (f2 cardType)
            (f3 cardNumber)
            (f4 cardExpiry)</code></pre></div>
<p><code>FApplicative</code> is a more general interface than <code>FRepresentable</code>, in that it supports notions of composition other than zipping. However, that bookkeeping <code>:-&gt;</code> <code>newtype</code> wrapper is inconvenient. With the normal <code>Applicative</code> class you can map an <em>n</em>-ary function over <em>n</em> applicative values directly: <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. With <code>FApplicative</code> you have to apply the <code>Morph</code> constructor as many times as <code>f</code> has arguments: <code>fpure (Morph $ \x -&gt; Morph $ \y -&gt; Morph $ \z -&gt; f x y z) `fap` t `fap` u `fap` v</code>, which becomes very unwieldy very quickly. (<a href="https://www.reddit.com/r/haskell/comments/78xxql/structures_of_arrays_functors_and_continuations/doy80ft/">/u/rampion has come up with nicer syntax for this</a>, but it involves <a href="https://gist.github.com/rampion/20291bde6c8568c11f9cc5923d9639eb#file-ffunctor-hs-L28">a more complicated formulation of <code>FApplicative</code></a>.) On the other hand, <code>FApplicative</code> does open up some interesting options for the design of <code>FTraversable</code>: one can traverse in an <code>FApplicative</code> rather than an <code>Applicative</code>. This gives some nice type signatures - <code>fsequence :: (FTraversable t, FApplicative f) =&gt; t f -&gt; f t</code> - and is strictly more general than the <code>FTraversable</code> I gave above, since any <code>Applicative</code> can be lifted into an <code>FApplicative</code> by composition (<code>newtype ComposeAt a f g = ComposeAt { getComposeAt :: f (g a) }</code>).</p>
<p>How useful are these tools in practice? Would I structure a production application around functor functors? Probably not. It’s a question of balance - while it’s useful to recognise functorial structures in categories other than <strong>Hask</strong> as a thinking tool, actually representing such abstractions in code doesn’t always pay off. Haskell already has a rich ecosystem of tools for working with the <code>Functor</code> family, but there’s much less code in the wild that’s structured around functor functors. This is partly because <code>Functor</code> has the advantage of being a standard class in <code>base</code>, but it’s also because code built around functor functors is a little less convenient to work with, typically requiring some tedious <code>newtype</code> bookkeeping.</p>
<p>Over the course of putting together this article I came across some work by others on this very topic. I’ve spotted versions of these classes being packaged with bigger libraries such as <a href="http://hackage.haskell.org/package/hedgehog-0.5.1/docs/Hedgehog-Internal-HTraversable.html"><code>hedgehog</code></a> and <a href="https://hackage.haskell.org/package/quickcheck-state-machine-0.2.0/docs/Test-StateMachine-Types-HFunctor.html"><code>quickcheck-state-machine</code></a>. There are also a few packages providing similar tools. The most mature of these seems to be <a href="http://hackage.haskell.org/package/rank2classes"><code>rank2classes</code></a>, which includes some Template Haskell tools for deriving instances; there’s also <a href="http://hackage.haskell.org/package/conkin">the Conkin package</a>, which has <a href="https://github.com/rampion/conkin/blob/master/README.md">a well-written tutorial</a> focusing on working with data in column-major order.</p>
<p>Haskell’s full of big ideas and powerful programming idioms. In this post we saw an example of reinterpreting some familiar tools - <code>Functor</code>, <code>Traversable</code> and <code>Representable</code> - in a new context. With the intuition that a record template is a container of functors, and the formalism of functors from the functor category, we were able to reuse intuitions about those familiar tools to write terse and generic programs.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on December 15, 2017</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2017-12-15-functor-functors/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
