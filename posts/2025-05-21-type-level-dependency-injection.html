<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>benjamin.pizza - Type-Level Dependency Injection</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2.1.1/out/water.min.css" integrity="sha256-QST90Wzz4PEr5KlclQaOCsjc00FTyf86Wrj41oqZB4w=" crossorigin="anonymous" />
        <link rel="stylesheet" type="text/css" href="../all.css" />
        <link rel="icon" href="../favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115911217-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-115911217-1');
        </script>
    </head>
    <body>
        <header id="header">
            <nav id="navigation">
                <ul>
                    <li id="logo"><a href="../">benjamin.pizza</a></li>
                    <li><a href="../about.html">About</a></li>
                    <li><a href="../atom.xml"><img src="../images/Feed-icon.svg" style="width: 14pt; margin-bottom: -3px;"></a></li>
                </ul>
            </nav>
        </header>

        <article>
            <header>
                <h1>Type-Level Dependency Injection</h1>
                
                
                    <p><time datetime="2025-05-21">May 21, 2025</time></p>
                
            </header>

            
<p>Let’s have fun with some of C#’s recent features.</p>
<p>Imagine you’re working on a recipe app. Users can type in what ingredients they have to hand and the app will suggest some recipe ideas from its library.</p>
<p>As usual, each service in the app gets an <code>interface</code>:</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ILogger</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">Log</span><span class="op">(</span><span class="dt">string</span> message<span class="op">);</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IRecipeRepository</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    IEnumerable<span class="op">&lt;</span>Recipe<span class="op">&gt;</span> <span class="fu">FindRecipesWithIngredient</span><span class="op">(</span><span class="dt">string</span> ingredientName<span class="op">);</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IRecipeSuggester</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>    IEnumerable<span class="op">&lt;</span>Recipe<span class="op">&gt;</span> <span class="fu">SuggestRecipes</span><span class="op">(</span>IEnumerable<span class="op">&lt;</span><span class="dt">string</span><span class="op">&gt;</span> ingredients<span class="op">);</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>When a service needs to depend on another service (via its interface), the traditional way is to use a class constructor: each dependency becomes a constructor parameter. You can change out implementations of a service by passing different arguments, and compose multiple dependencies by using multiple parameters. While it’s <em>possible</em> to hand-write your app’s composition root with <code>new</code> expressions, it can be tedious, so people use an IOC container which calls all of your services’ constructors by magic.</p>
<p>The design I want to explore instead involves declaring dependencies by using <strong>constraints on a type parameter</strong>. Each service in the system is going to take a <code>TServices</code> type parameter,</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TopTenRecipeSuggester<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> IRecipeSuggester</span></code></pre></div><p>and each <code>interface</code> will have a corresponding “provider”.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ILoggerProvider</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">abstract</span> ILogger Logger <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IRecipeRepositoryProvider</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">abstract</span> IRecipeRepository RecipeRepository <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IRecipeSuggesterProvider</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> <span class="kw">abstract</span> IRecipeSuggester RecipeSuggester <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>(Why make these abstract properties <code>static</code>? It’ll become clear later.) I think of these provider interfaces as defining composable fragments of a <em>namespace</em>. Each provider claims one name (or more, why not) for its corresponding interface(s). Generic type constraints let us put the building blocks together.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TopTenRecipeSuggester<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> IRecipeSuggester</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> IRecipeRepositoryProvider<span class="op">,</span> ILoggerProvider</span></code></pre></div><p>That’s why the providers need to be interfaces — so we can use more than one in a constraint.</p>
<p>This is nice and composable. Each service specifies exactly the dependencies it needs, as a set of constraints on the shared <code>TServices</code> type parameter. The type system takes care of union-ing these constraints; eventually we’ll specify a single concrete type to stand in for all the instances of <code>TServices</code> and we’ll be required to implement exactly the providers that were requested by the services.</p>
<p>Now when the code needs to call a dependency, it just looks it up in the <code>TServices</code> namespace.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TopTenRecipeSuggester<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> IRecipeSuggester</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> IRecipeRepositoryProvider<span class="op">,</span> ILoggerProvider</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> IEnumerable<span class="op">&lt;</span>Recipe<span class="op">&gt;</span> <span class="fu">SuggestRecipes</span><span class="op">(</span>IEnumerable<span class="op">&lt;</span><span class="dt">string</span><span class="op">&gt;</span> ingredients<span class="op">)</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>        TServices<span class="op">.</span><span class="fu">Logger</span><span class="op">.</span><span class="fu">Log</span><span class="op">(</span><span class="st">&quot;finding recipes...&quot;</span><span class="op">);</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> results <span class="op">=</span> <span class="op">(</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>            from i <span class="kw">in</span> ingredients</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>            from r <span class="kw">in</span> TServices<span class="op">.</span><span class="fu">RecipeRepository</span><span class="op">.</span><span class="fu">FindRecipesWithIngredient</span><span class="op">(</span>i<span class="op">)</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>            group i by r into g</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>            orderby g<span class="op">.</span><span class="fu">Count</span><span class="op">()</span> descending</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>            select g<span class="op">.</span><span class="fu">Key</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>        <span class="op">).</span><span class="fu">Take</span><span class="op">(</span><span class="dv">10</span><span class="op">).</span><span class="fu">ToList</span><span class="op">();</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>        TServices<span class="op">.</span><span class="fu">Logger</span><span class="op">.</span><span class="fu">Log</span><span class="op">(</span><span class="st">&quot;found some recipes&quot;</span><span class="op">);</span></span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a></span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> results<span class="op">;</span></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>The dependencies are injected through a single (type) parameter. Is this <a href="https://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">the dreaded “Service Locator” anti-pattern</a>? <strong>No!</strong> The issue with Service Locator is that it makes dependencies invisible: you can’t tell how to set up a component’s dependencies without reading its source code. The constraints on the <code>TServices</code> type parameter are explicit and visible. If you want to use a service, you’re forced by the type checker to satisfy its dependencies. And the service class can’t access any dependencies other than the ones declared in the <code>where</code> clause.</p>
<p>How <em>do</em> you satisfy a set of dependencies? At the app’s <a href="https://blog.ploeh.dk/2012/11/06/WhentouseaDIContainer/#0c19d443c1ad4fd6a4c7883dcc9abb3c">composition root</a>, we need to provide a type that can stand in for the <code>TServices</code> type parameter. That amounts to defining a class that implements all of the <code>Provider</code> interfaces by supplying a concrete implementation of each service.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CompositionRoot <span class="op">:</span> ILoggerProvider<span class="op">,</span> IRecipeRepositoryProvider<span class="op">,</span> IRecipeSuggesterProvider</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CompositionRoot supplies itself as the TServices type parameter</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">static</span> ILogger Logger <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> ConsoleLogger<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;();</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">static</span> IRecipeRepository RecipeRepository <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> DbRecipeRepository<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;();</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">static</span> IRecipeSuggester RecipeSuggester <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> TopTenRecipeSuggester<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;();</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>Finally, at the app’s entry point, you can pick out services directly from the <code>CompositionRoot</code>. (Typically you want to keep this layer thin: just call out to a controller object.)</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">// Program.cs</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>CompositionRoot<span class="op">.</span><span class="fu">RecipeSuggestionController</span><span class="op">.</span><span class="fu">Run</span><span class="op">();</span></span></code></pre></div><h2 id="composable-composition-root"><a href="#composable-composition-root">Composable Composition Root</a></h2>
<p>One problem with the <code>CompositionRoot</code> is that it’s difficult to swap out an implementation of a service. <code>CompositionRoot</code> passes itself as the <code>TServices</code> type parameter — not “the concrete type of the instance” — so you can’t override a property by subclassing it.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TestCompositionRoot <span class="op">:</span> CompositionRoot</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This doesn't work - the TopTenRecipeSuggester is still going to</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// look in CompositionRoot to find its dependencies.</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">static</span> <span class="kw">override</span> IRecipeRepository RecipeRepository <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> MockRecipeRepository<span class="op">&lt;</span>TestCompositionRoot<span class="op">&gt;();</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>You’d have to define an entirely separate composition root for testing instead.</p>
<blockquote class="callout callout-aside">
<h3>Aside</h3>
<p>I actually don’t think this is too bad, or at least, it’s also a weak spot for classic constructor injection. With classic constructor injection, tests typically <code>new</code> up the SUT and specify all of its dependencies by hand anyway. Type-Level DI has somewhat more boilerplate but not, like, asymptotically more.</p>
</blockquote>
<p>Anyway, we can patch this up using one of my favourite cursed tricks: <em>F-bounds</em> (aka the <em>curiously recurring template pattern</em>). <code>CompositionRoot</code> will (become an interface and) take a <code>TServices</code> type parameter itself. <code>TServices</code> stands in for the eventual concrete type of the composition root.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ICompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> ILoggerProvider<span class="op">,</span> IRecipeRepositoryProvider<span class="op">,</span> IRecipeSuggesterProvider</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> ILogger ILoggerProvider<span class="op">.</span><span class="fu">Logger</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> ConsoleLogger<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeRepository IRecipeRepositoryProvider<span class="op">.</span><span class="fu">RecipeRepository</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> DbRecipeRepository<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeSuggester IRecipeSuggesterProvider<span class="op">.</span><span class="fu">RecipeSuggester</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> TopTenRecipeSuggester<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><blockquote class="callout callout-aside">
<h3>Aside</h3>
<p>Now you can see why I made the providers’ properties <code>static</code>. Interfaces can’t have (non-static) fields, and accordingly non-static interface properties can’t have initialisers because there’s no corresponding storage location.</p>
</blockquote>
<p>This arrangement allows you to derive another interface from <code>CompositionRoot</code>, override whatever you need, and forward the type parameter.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IMockCompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> IMockCompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeRepository IRecipeRepositoryProvider<span class="op">.</span><span class="fu">RecipeRepository</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> MockRecipeRepository<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>Eventually, when it’s time to run code, someone will derive an <em>empty</em> concrete class which plugs itself in as the <code>TServices</code> type parameter.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CompositionRoot <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;</span> <span class="op">{}</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MockCompositionRoot <span class="op">:</span> IMockCompositionRoot<span class="op">&lt;</span>MockCompositionRoot<span class="op">&gt;</span> <span class="op">{}</span></span></code></pre></div><p>Why stop here? Let’s split up <code>CompositionRoot</code>’s fields into individual interfaces. Each concrete service implementation now has its own provider…</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IConsoleLoggerProvider<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> ILoggerProvider</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> ILogger ILoggerProvider<span class="op">.</span><span class="fu">Logger</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> ConsoleLogger<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> IDbRecipeRepositoryProvider<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> IRecipeRepositoryProvider</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeRepository IRecipeRepositoryProvider<span class="op">.</span><span class="fu">RecipeRepository</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> DbRecipeRepository<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ITopTenRecipeSuggesterProvider<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span> IRecipeSuggesterProvider</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> ILoggerProvider<span class="op">,</span> IRecipeRepositoryProvider</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeSuggester IRecipeSuggesterProvider<span class="op">.</span><span class="fu">RecipeSuggester</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> TopTenRecipeSuggester<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>… and the <code>CompositionRoot</code> just composes the concrete providers by inheritance, once again passing itself as the <code>TServices</code> type parameter. You don’t need to write out the concrete service implementations any more.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CompositionRoot <span class="op">:</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    IConsoleLoggerProvider<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;,</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    IDbRecipeRepositoryProvider<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;,</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    ITopTenRecipeSuggesterProvider<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>Beautiful! (I rather like nesting the concrete providers inside their corresponding concrete service, so, <code>ConsoleLogger&lt;TServices&gt;.Provider</code> instead of <code>IConsoleLoggerProvider&lt;TServices&gt;</code>. You can even nest the abstract providers in the service interfaces: <code>ILogger.Provider</code>.)</p>
<p>You can mix and match if you like: bundle some or all of your services into a single interface, and override them one at a time with inheritance.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ICompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span> <span class="op">:</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    IConsoleLoggerProvider<span class="op">&lt;</span>TServices<span class="op">&gt;,</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    IDbRecipeRepositoryProvider<span class="op">&lt;</span>TServices<span class="op">&gt;,</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    ITopTenRecipeSuggesterProvider<span class="op">&lt;</span>TServices<span class="op">&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    where TServices <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>TServices<span class="op">&gt;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CompositionRoot <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MockCompositionRoot <span class="op">:</span> ICompositionRoot<span class="op">&lt;</span>MockCompositionRoot<span class="op">&gt;</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> IRecipeRepository IRecipeRepositoryProvider<span class="op">.</span><span class="fu">RecipeRepository</span> <span class="op">{</span> <span class="kw">get</span><span class="op">;</span> <span class="op">}</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="kw">new</span> MockRecipeRepository<span class="op">&lt;</span>TServices<span class="op">&gt;();</span></span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><p>There’s one minor inconvenience with this arrangement: at your app’s entry point, it’s now a little more difficult to use <code>CompositionRoot</code> directly. You have to go via a (constrained) type parameter to access the interface’s static properties.</p>
<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">// Program.cs</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>GetController<span class="op">&lt;</span>CompositionRoot<span class="op">&gt;().</span><span class="fu">Run</span><span class="op">();</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> IRecipeSuggestionController GetController<span class="op">&lt;</span>T<span class="op">&gt;()</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    where T <span class="op">:</span> IRecipeSuggestionControllerProvider</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="op">=&gt;</span> T<span class="op">.</span><span class="fu">RecipeSuggestionController</span><span class="op">;</span></span></code></pre></div><p>Writing an additional provider interface for each component in your system (a concrete provider for each concrete service, and an abstract provider for each of their interfaces) is tedious boilerplate, but at least it’s the kind of thing you can automate with a source generator.</p>
<h2 id="some-thoughts-on-modules"><a href="#some-thoughts-on-modules">Some Thoughts on Modules</a></h2>
<p>Why do we do dependency injection with constructors and interfaces? Object oriented languages expect you to do all your modelling, at every level of your system, using the tools of objects. But in practice I feel there are (at least) two separate types of objects. Honest-to-goodness <em>objects</em> manage data, have a lifetime, may have many instances. But <em>services</em> are really just organisational conveniences — they simply bundle up a set of functions and dependencies, they’re stateless, and there’s typically only one of each service in a given application.</p>
<p>It’s weird that we model both of these concepts with classes! We want to do <strong>modular</strong> programming: make components loosely coupled, program to well-designed interfaces and hide implementations. But mainstream object oriented languages don’t have tools for programming modules, so we’re stuck reusing constructs that are better suited to managing units of data. Shut up and write classes!</p>
<p>I freely admit my design for TLDI is grotesque. But let’s admit that IOC containers like <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection">MEDI</a> are grotesque too. They exist to paper over the deficiency of modular programming in OO languages. It was tedious to write <code>new</code> statements to wire up concrete dependencies for every service in your system, and frameworks like ASP.NET needed a generic way to create instances of service classes, manage their lifetimes, and provide their dependencies. I don’t think IOC registration code is very much more tasteful than <code>new</code> statements, but in any case we should recognise that “instances of service classes” is a thoroughly object-oriented framing of the problem: IOC containers are caused by constructor injection.</p>
<p>I don’t quite understand why today’s industrial strength languages don’t have built-in facilities for managing components and dependencies. I would love to see a language (other than OCaml) take modular programming and dependency injection seriously. Maybe next time I’ll jot down some ideas of how to design such a system.</p>


        </article>

        <footer id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
