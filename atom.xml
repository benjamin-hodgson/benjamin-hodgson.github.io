<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>benjamin.pizza</title>
    <link href="http://www.benjamin.pizza/atom.xml" rel="self" />
    <link href="http://www.benjamin.pizza" />
    <id>http://www.benjamin.pizza/atom.xml</id>
    <author>
        <name>Benjamin Hodgson</name>
        <email>bhodgson@stackoverflow.com</email>
    </author>
    <updated>2018-12-06T00:00:00Z</updated>
    <entry>
    <title>Zooming In on Field Accessors</title>
    <link href="http://www.benjamin.pizza/posts/2018-12-06-zooming-in-on-field-accessors.html" />
    <id>http://www.benjamin.pizza/posts/2018-12-06-zooming-in-on-field-accessors.html</id>
    <published>2018-12-06T00:00:00Z</published>
    <updated>2018-12-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December  6, 2018
    
</div>

<p>It‚Äôs common in functional languages ‚Äî and increasingly in hybrid languages like C# ‚Äî to work with complex systems of immutable datatypes. For a contrived example, suppose you‚Äôre working on a billing application:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> Order</a>
<a class="sourceLine" id="cb1-2" title="2">{</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">public</span> Customer Customer { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">public</span> ImmutableList&lt;Product&gt; Products { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-5" title="5">}</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">class</span> Customer</a>
<a class="sourceLine" id="cb1-7" title="7">{</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">public</span> <span class="dt">string</span> Name { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">public</span> Address Address { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-10" title="10">}</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">class</span> Address</a>
<a class="sourceLine" id="cb1-12" title="12">{</a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="kw">public</span> <span class="dt">string</span> Line1 { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="kw">public</span> <span class="dt">string</span> Line2 { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="kw">public</span> <span class="dt">string</span> Postcode { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-16" title="16">}</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">class</span> Product</a>
<a class="sourceLine" id="cb1-18" title="18">{</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="kw">public</span> <span class="dt">string</span> Title { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="kw">public</span> <span class="dt">decimal</span> Price { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-21" title="21">}</a></code></pre></div>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/model.jpg" width="900" /></p>
<p>(I‚Äôve omitted the constructors; you can imagine your own.) These objects are immutable, meaning you can‚Äôt modify them directly. The way to update an immutable object is to make a copy of that object with the relevant properties changed. This turns out to be surprisingly tedious when you‚Äôre working inside a deeply nested structure:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb2-1" title="1">Order <span class="fu">UpdatePostcode</span>(Order order<span class="co">/*üë®üèª‚Äç‚öñÔ∏è*/</span>, <span class="dt">string</span> newPostcode)</a>
<a class="sourceLine" id="cb2-2" title="2">    =&gt; <span class="kw">new</span> <span class="fu">Order</span>(</a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="kw">new</span> <span class="fu">Customer</span>(</a>
<a class="sourceLine" id="cb2-4" title="4">            order.<span class="fu">Customer</span>.<span class="fu">Name</span>,</a>
<a class="sourceLine" id="cb2-5" title="5">            <span class="kw">new</span> <span class="fu">Address</span>(</a>
<a class="sourceLine" id="cb2-6" title="6">                order.<span class="fu">Customer</span>.<span class="fu">Address</span>.<span class="fu">Line1</span>,</a>
<a class="sourceLine" id="cb2-7" title="7">                order.<span class="fu">Customer</span>.<span class="fu">Address</span>.<span class="fu">Line2</span>,</a>
<a class="sourceLine" id="cb2-8" title="8">                newPostcode</a>
<a class="sourceLine" id="cb2-9" title="9">            )</a>
<a class="sourceLine" id="cb2-10" title="10">        ),</a>
<a class="sourceLine" id="cb2-11" title="11">        order.<span class="fu">Products</span></a>
<a class="sourceLine" id="cb2-12" title="12">    );</a></code></pre></div>
<p>F#‚Äôs <code>with</code>-syntax helps a little, but not a lot. You still have to write each name multiple times.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> updatePostcode(order : Order, newPostcode : <span class="dt">string</span>) : Order = {</a>
<a class="sourceLine" id="cb3-2" title="2">  order <span class="kw">with</span> customer = {</a>
<a class="sourceLine" id="cb3-3" title="3">    order.customer <span class="kw">with</span> address = {</a>
<a class="sourceLine" id="cb3-4" title="4">      order.customer.address <span class="kw">with</span> postcode = newPostcode</a>
<a class="sourceLine" id="cb3-5" title="5">    }</a>
<a class="sourceLine" id="cb3-6" title="6">  }</a>
<a class="sourceLine" id="cb3-7" title="7">}</a></code></pre></div>
<p>This pain is caused by immutability. In an imperative setting you can say <code>order.Customer.Address.Postcode = newPostcode;</code>, although of course mutable data is less reliable and harder to work with overall. Rather than give up on immutability, functional programmers have invented a remarkable family of composable tools called <em>optics</em> for poking around inside complex datatypes. Optics are a way of describing ‚Äúpaths‚Äù through structures: you can compose paths together, and read and write the values at the end of those paths. I‚Äôm here today to demonstrate that C#8‚Äôs upcoming <a href="https://github.com/dotnet/csharplang/issues/52"><em>default interface methods</em></a> are great at modelling optics.</p>
<p>Let‚Äôs start with <em>lenses</em>, the family member that gave the family its name.</p>
<h2 id="lenses">Lenses</h2>
<p>A <em>lens</em> is a first-class property for an immutable object. It‚Äôs an object with a pair of methods, a <em>getter</em> which retrives the value of a property and a <em>setter</em> which updates it. Remember, we‚Äôre working with immutable data, so the setter returns a new copy of the object.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb4-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb4-5" title="5">}</a></code></pre></div>
<p>For example, here‚Äôs a lens which focuses on a <code>Customer</code>‚Äôs <code>Address</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> AddressL : ILens&lt;Customer, Address&gt;</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">public</span> Address <span class="fu">Get</span>(Customer c) =&gt; c.<span class="fu">Address</span>;</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">public</span> Customer <span class="fu">Set</span>(Customer c, Address a) =&gt; <span class="kw">new</span> <span class="fu">Customer</span>(c.<span class="fu">Name</span>, a);</a>
<a class="sourceLine" id="cb5-6" title="6">}</a></code></pre></div>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/customer.jpg" width="900" /></p>
<p>So a lens picks out a single property inside a given object.</p>
<p>The power of lenses comes from their composability. Given a lens identifying a <code>T2</code> inside a <code>T1</code> (<code>ILens&lt;T1, T2&gt;</code>) and a lens identifying a <code>T3</code> inside a <code>T2</code> (<code>ILens&lt;T2, T3&gt;</code>), you can compose those lenses together to focus all the way from the <code>T1</code> to the <code>T3</code>.</p>
<p>You can traverse any relationship in your data model by composing together a small number of individual lenses. Composing lenses is so important that I‚Äôve given it the shortest name I can think of: <code>_</code>. (Readers of <a href="2018-03-16-eighty.html">an eariler post of mine</a> will know of my fondness for <code>_</code>.)</p>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/postcode.jpg" width="900" /></p>
<p>Compare this terse, declarative code with the tedious version of <code>UpdatePostcode</code> from the beginning:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb6-1" title="1">Order <span class="fu">UpdatePostcode</span>(Order order<span class="co">/*üë®üèª‚Äç‚öñÔ∏è*/</span>, <span class="dt">string</span> newPostcode)</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3">    ILens&lt;Order, <span class="dt">string</span>&gt; l = <span class="kw">new</span> <span class="fu">CustomerL</span>()</a>
<a class="sourceLine" id="cb6-4" title="4">        ._(<span class="kw">new</span> <span class="fu">AddressL</span>())</a>
<a class="sourceLine" id="cb6-5" title="5">        ._(<span class="kw">new</span> <span class="fu">PostcodeL</span>());</a>
<a class="sourceLine" id="cb6-6" title="6">    </a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">return</span> l.<span class="fu">Set</span>(order, newPostcode);</a>
<a class="sourceLine" id="cb6-8" title="8">}</a></code></pre></div>
<p>Lenses work without reference to any particular instance. (This is called <del><em>pointless</em></del> <a href="https://stackoverflow.com/questions/944446/what-is-point-free-style-in-functional-programming"><em>point-free</em></a> programming.) <code>order.Customer.Address.Postcode</code> becomes <code>new CustomerL()._(new AddressL())._(new PostcodeL())</code> ‚Äî the path of properties is sort of detached from the object itself. Treating a path through a datatype as a first class value is the big idea behind lenses.</p>
<p>Here‚Äôs how <code>_</code> is implemented. It returns a new <code>ILens</code> (an instance of a private class) which delegates to the two smaller lenses.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> ILens&lt;T1, T3&gt; _&lt;T1, T2, T3&gt;(<span class="kw">this</span> ILens&lt;T1, T2&gt; l1, ILens&lt;T2, T3&gt; l2)</a>
<a class="sourceLine" id="cb7-4" title="4">        =&gt; <span class="kw">new</span> ComposedLens&lt;T1, T2, T3&gt;(l1, l2);</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">private</span> <span class="kw">class</span> ComposedLens&lt;T1, T2, T3&gt; : ILens&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb7-7" title="7">    {</a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="kw">private</span> <span class="kw">readonly</span> ILens&lt;T1, T2&gt; _l1;</a>
<a class="sourceLine" id="cb7-9" title="9">        <span class="kw">private</span> <span class="kw">readonly</span> ILens&lt;T2, T3&gt; _l2;</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="kw">public</span> T3 <span class="fu">Get</span>(T1 obj) =&gt; _l2.<span class="fu">Get</span>(_l1.<span class="fu">Get</span>(obj));</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="kw">public</span> T1 <span class="fu">Set</span>(T1 oldObj, T3 newVal)</a>
<a class="sourceLine" id="cb7-14" title="14">            =&gt; _l1.<span class="fu">Set</span>(oldObj, _l2.<span class="fu">Set</span>(_l1.<span class="fu">Get</span>(oldObj), newVal));</a>
<a class="sourceLine" id="cb7-15" title="15">    }</a>
<a class="sourceLine" id="cb7-16" title="16">}</a></code></pre></div>
<p>To summarise, a lens is a way to focus on a small part of a big immutable structure. They‚Äôre like a first-class version of the <code>.</code> and <code>=</code> operators: you can compose lenses together to focus deeper, and upon focusing on a location you can get and set the value at that location.</p>
<h3 id="mapping-under-a-lens">Mapping under a lens</h3>
<p>A common pattern is to get a value from a lens, apply some sort of transformation to it, and then put it back where it was. The <code>Map</code> helper function wraps up this pattern:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb8-2" title="2">{</a>
<a class="sourceLine" id="cb8-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb8-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb8-7" title="7">        =&gt; <span class="fu">Set</span>(oldObj, <span class="fu">transformer</span>(<span class="fu">Get</span>(oldObj))).</a>
<a class="sourceLine" id="cb8-8" title="8">}</a></code></pre></div>
<p>Here‚Äôs an early taste of a default interface implementation. The default, <em><code>Get</code>-then-<code>Set</code></em>, works correctly, but when you‚Äôre working with deeply stacked lenses it can be inefficient to walk the whole data structure twice. (This is especially true of <em>multi-lenses</em> ‚Äî of which more later ‚Äî which build and discard a large number of intermediate enumerables.) If <code>Map</code> were an extension method, it would be impossible for users to override it and provide a more efficient implementation.</p>
<hr />
<p>Powerful as they are, these lenses don‚Äôt quite scale up to cover all of the important ways to access data. Specifically, they don‚Äôt support computed properties or lists.</p>
<h2 id="getters">Getters</h2>
<p>How would you write a lens which focuses on a list‚Äôs <code>Count</code>? You can‚Äôt set <code>Count</code> directly - it measures the number of times you‚Äôve added or removed something from the list. The only way to change the <code>Count</code> is to add or remove an item!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">class</span> CountL&lt;T&gt; : ILens&lt;ImmutableList&lt;T&gt;, <span class="dt">int</span>&gt;</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">Get</span>(ImmutableList&lt;T&gt; l) =&gt; l.<span class="fu">Count</span>;</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="kw">public</span> ImmutableList&lt;T&gt; <span class="fu">Set</span>(ImmutableList&lt;T&gt; l, <span class="dt">int</span> count) =&gt; <span class="co">/* ??? */</span>;</a>
<a class="sourceLine" id="cb9-5" title="5">}</a></code></pre></div>
<p>Clearly we need to separate the ‚Äúgetting‚Äù and ‚Äúsetting‚Äù reponsibilities of <code>ILens</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">interface</span> IGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb10-4" title="4">}</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb10-6" title="6">{</a>
<a class="sourceLine" id="cb10-7" title="7">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb10-8" title="8">}</a></code></pre></div>
<p>We don‚Äôt lose composability by doing this. You can still compose two getters to get a getter.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb11-2" title="2">{</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> IGetter&lt;T1, T3&gt; <span class="fu">_</span>(</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="kw">this</span> IGetter&lt;T1, T2&gt; g1,</a>
<a class="sourceLine" id="cb11-5" title="5">        IGetter&lt;T2, T3&gt; g2</a>
<a class="sourceLine" id="cb11-6" title="6">    ) =&gt; <span class="kw">new</span> ComposedGetter&lt;T1, T2, T3&gt;(g1, g2);</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">private</span> <span class="kw">class</span> ComposedGetter&lt;T1, T2, T3&gt; : IGetter&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb11-9" title="9">    {</a>
<a class="sourceLine" id="cb11-10" title="10">        <span class="kw">private</span> <span class="kw">readonly</span> IGetter&lt;T1, T2&gt; _g1;</a>
<a class="sourceLine" id="cb11-11" title="11">        <span class="kw">private</span> <span class="kw">readonly</span> IGetter&lt;T2, T3&gt; _g2;</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13">        <span class="kw">public</span> T3 <span class="fu">Get</span>(T1 obj) =&gt; _g2.<span class="fu">Get</span>(_g1.<span class="fu">Get</span>(obj));</a>
<a class="sourceLine" id="cb11-14" title="14">    }</a>
<a class="sourceLine" id="cb11-15" title="15">}</a></code></pre></div>
<p>If you compose a lens with a getter, you get a getter. This makes sense: if any part of a given path through a data structure is read-only, then the whole path must be read-only. It Just Works‚Ñ¢ because <code>ILens</code> is a subtype of <code>IGetter</code>. Overload resolution takes care of it: you type <code>_</code> and the compiler picks the right return type based on the types of <code>_</code>‚Äôs arguments.</p>
<h2 id="multi-lenses">Multi-lenses</h2>
<p><code>ILens</code> focuses on a single part of a structure. Its <code>Get</code> method returns a single <code>TProp</code> and its <code>Set</code> method takes a single <code>TProp</code>. This means you can‚Äôt use lenses to, for example, update the price of all the products in an order.</p>
<p>Enter <em>multi-lenses</em>, also known as <em>traversals</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">interface</span> IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb12-2" title="2">{</a>
<a class="sourceLine" id="cb12-3" title="3">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj);</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="co">// newVals should be the same length as the list returned by MultiGet</span></a>
<a class="sourceLine" id="cb12-5" title="5">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals);</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb12-8" title="8">        =&gt; <span class="fu">MultiSet</span>(oldObj, <span class="fu">MultiGet</span>(oldObj).<span class="fu">Select</span>(transformer)).</a>
<a class="sourceLine" id="cb12-9" title="9">}</a></code></pre></div>
<p>(Readers of <a href="2017-11-13-recursion-without-recursion.html">an earlier post</a> might recognise <code>IMultiLens</code> as a generalisation of <code>IRewriter</code>.) A multi-lens is like a lens which can hit more than one target. While a lens focuses on <em>exactly one</em> <code>TProp</code> inside a <code>T</code>, a multi-lens relaxes that restriction, focusing on <em>zero-or-many</em> <code>TProps</code> at once.</p>
<p>Here‚Äôs an example multi-lens which focuses on all of the <code>Product</code>s in an <code>Order</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">class</span> ProductsL : IMultiLens&lt;Order, Product&gt;</a>
<a class="sourceLine" id="cb13-2" title="2">{</a>
<a class="sourceLine" id="cb13-3" title="3">    IEnumerable&lt;Product&gt; <span class="fu">MultiGet</span>(Order order) =&gt; order.<span class="fu">Products</span>;</a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">    Order <span class="fu">MultiSet</span>(Order order, IEnumerable&lt;Product&gt; newProducts)</a>
<a class="sourceLine" id="cb13-6" title="6">        =&gt; <span class="kw">new</span> <span class="fu">Order</span>(order.<span class="fu">Customer</span>, newProducts);</a>
<a class="sourceLine" id="cb13-7" title="7">}</a></code></pre></div>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/products.jpg" width="900" /></p>
<p>You can compose multi-lenses, too. If you have a multi-lens which finds <span class="math inline"><em>n</em></span> <code>T2</code>s inside a <code>T1</code>, and a second multi-lens which finds <span class="math inline"><em>m</em></span> <code>T3</code>s inside a <code>T2</code>, you can build a multi-lens which finds <span class="math inline"><em>n</em><em>m</em></span> <code>T3</code>s inside a <code>T1</code>. This works by looking through the second multi-lens at all <span class="math inline"><em>n</em></span> of the first multi-lens‚Äôs targets.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">static</span> <span class="kw">class</span> LensExtensions</a>
<a class="sourceLine" id="cb14-2" title="2">{</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">public</span> <span class="kw">static</span> IMultiLens&lt;T1, T3&gt; <span class="fu">_</span>(</a>
<a class="sourceLine" id="cb14-4" title="4">        <span class="kw">this</span> IMultiLens&lt;T1, T2&gt; m1,</a>
<a class="sourceLine" id="cb14-5" title="5">        IMultiLens&lt;T2, T3&gt; m2</a>
<a class="sourceLine" id="cb14-6" title="6">    ) =&gt; <span class="kw">new</span> ComposedMultiLens&lt;T1, T2, T3&gt;(m1, m2);</a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="kw">private</span> <span class="kw">class</span> ComposedMultiLens&lt;T1, T2, T3&gt; : IMultiLens&lt;T1, T3&gt;</a>
<a class="sourceLine" id="cb14-9" title="9">    {</a>
<a class="sourceLine" id="cb14-10" title="10">        <span class="kw">private</span> <span class="kw">readonly</span> IMultiLens&lt;T1, T2&gt; _m1;</a>
<a class="sourceLine" id="cb14-11" title="11">        <span class="kw">private</span> <span class="kw">readonly</span> IMultiLens&lt;T2, T3&gt; _m2;</a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13">        <span class="kw">public</span> IEnumerable&lt;T3&gt; <span class="fu">MultiGet</span>(T1 obj)</a>
<a class="sourceLine" id="cb14-14" title="14">            =&gt; _m1.<span class="fu">MultiGet</span>(obj).<span class="fu">SelectMany</span>(_m2.<span class="fu">MultiGet</span>);</a>
<a class="sourceLine" id="cb14-15" title="15"></a>
<a class="sourceLine" id="cb14-16" title="16">        <span class="kw">public</span> T1 <span class="fu">MultiSet</span>(T1 oldObj, IEnumerable&lt;T3&gt; newVals)</a>
<a class="sourceLine" id="cb14-17" title="17">        {</a>
<a class="sourceLine" id="cb14-18" title="18">            IEnumerable&lt;T2&gt; <span class="fu">NewT2s</span>()</a>
<a class="sourceLine" id="cb14-19" title="19">            {</a>
<a class="sourceLine" id="cb14-20" title="20">                <span class="kw">foreach</span> (<span class="dt">var</span> x <span class="kw">in</span> _m1.<span class="fu">MultiGet</span>(oldObj))</a>
<a class="sourceLine" id="cb14-21" title="21">                {</a>
<a class="sourceLine" id="cb14-22" title="22">                    <span class="dt">var</span> chunkLength = _m2.<span class="fu">MultiGet</span>(x).<span class="fu">Count</span>();</a>
<a class="sourceLine" id="cb14-23" title="23">                    <span class="kw">yield</span> <span class="kw">return</span> _m2.<span class="fu">MultiSet</span>(x, newVals.<span class="fu">Take</span>(chunkLength));</a>
<a class="sourceLine" id="cb14-24" title="24">                    newVals = newVals.<span class="fu">Skip</span>(chunkLength);</a>
<a class="sourceLine" id="cb14-25" title="25">                }</a>
<a class="sourceLine" id="cb14-26" title="26">            }</a>
<a class="sourceLine" id="cb14-27" title="27">            <span class="kw">return</span> _m1.<span class="fu">MultiSet</span>(oldObj, <span class="fu">NewT2s</span>());</a>
<a class="sourceLine" id="cb14-28" title="28">        }</a>
<a class="sourceLine" id="cb14-29" title="29">    }</a>
<a class="sourceLine" id="cb14-30" title="30">}</a></code></pre></div>
<p><code>MultiSet</code> chops <code>newVals</code> into chunks that are the length of each group of descendants. This is safe as long as a user never calls <code>MultiSet</code> with a different number of elements than was returned by <code>MultiGet</code>.</p>
<p>So far we can compose multi-lenses on their own, but they don‚Äôt yet interoperate well with lenses. But note multi-lenses generalise lenses by relaxing the requirement that there should be exactly one substructure. Every lens is also a multi-lens by forgetting that there‚Äôs a single <code>TProp</code>. (Once again we‚Äôre relying on the assumption that the list does not change length in between <code>MultiGet</code> and <code>MultiSet</code> calls.)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb15-2" title="2">{</a>
<a class="sourceLine" id="cb15-3" title="3">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb15-4" title="4">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj)</a>
<a class="sourceLine" id="cb15-7" title="7">        =&gt; <span class="kw">new</span>[] { <span class="fu">Get</span>(obj) };</a>
<a class="sourceLine" id="cb15-8" title="8">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals)</a>
<a class="sourceLine" id="cb15-9" title="9">        =&gt; <span class="fu">Set</span>(oldObj, newVals.<span class="fu">Single</span>());</a>
<a class="sourceLine" id="cb15-10" title="10">}</a></code></pre></div>
<p>Inheriting from <code>IMultiLens</code> like this is just the same trick as inheriting from <code>IGetter</code>. It allows you to compose a lens with a multi-lens using <code>_</code>; the result will be a multi-lens.</p>
<p>If lenses are like a first-class <code>.</code>, then multi-lenses are like a first-class <code>Select</code>. Composing a lens onto the end of a multi-lens is like <code>Select</code>ing a field from each element of a list, with the added power of being able to write new values to the list. Like lenses, multi-lenses are point-free: you compose a multi-lens describing a path through a datatype, then apply that multi-lens to a specific instance of the datatype.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb16-1" title="1">Order <span class="fu">TwentyPercentOff</span>(Order order)</a>
<a class="sourceLine" id="cb16-2" title="2">{</a>
<a class="sourceLine" id="cb16-3" title="3">    IMultiLens&lt;Order, <span class="dt">decimal</span>&gt; l = <span class="kw">new</span> <span class="fu">ProductsL</span>()._(<span class="kw">new</span> <span class="fu">PriceL</span>());</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="kw">return</span> l.<span class="fu">Map</span>(order, x =&gt; x * <span class="fl">0.8</span>);</a>
<a class="sourceLine" id="cb16-5" title="5">}</a></code></pre></div>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/product-and-price.jpg" width="900" /></p>
<p>Incorporating the earlier <code>IGetter</code> fix, and extending <code>IMultiLens</code> upwards in parallel, leaves us with the following hierarchy.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">interface</span> IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-2" title="2">{</a>
<a class="sourceLine" id="cb17-3" title="3">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj);</a>
<a class="sourceLine" id="cb17-4" title="4">}</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">interface</span> IMultiLens&lt;T, TProp&gt; : IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-6" title="6">{</a>
<a class="sourceLine" id="cb17-7" title="7">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals);</a>
<a class="sourceLine" id="cb17-8" title="8"></a>
<a class="sourceLine" id="cb17-9" title="9">    T <span class="fu">Map</span>(T oldObj, Func&lt;TProp, TProp&gt; transformer)</a>
<a class="sourceLine" id="cb17-10" title="10">        =&gt; <span class="fu">MultiSet</span>(oldObj, <span class="fu">MultiGet</span>(oldObj).<span class="fu">Select</span>(transformer));</a>
<a class="sourceLine" id="cb17-11" title="11">}</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="kw">interface</span> IGetter&lt;T, TProp&gt; : IMultiGetter&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-13" title="13">{</a>
<a class="sourceLine" id="cb17-14" title="14">    TProp <span class="fu">Get</span>(T obj);</a>
<a class="sourceLine" id="cb17-15" title="15"></a>
<a class="sourceLine" id="cb17-16" title="16">    IEnumerable&lt;TProp&gt; <span class="fu">MultiGet</span>(T obj)</a>
<a class="sourceLine" id="cb17-17" title="17">        =&gt; <span class="kw">new</span>[] { <span class="fu">Get</span>(obj) };</a>
<a class="sourceLine" id="cb17-18" title="18">}</a>
<a class="sourceLine" id="cb17-19" title="19"><span class="kw">interface</span> ILens&lt;T, TProp&gt; : IGetter&lt;T, TProp&gt;, IMultiLens&lt;T, TProp&gt;</a>
<a class="sourceLine" id="cb17-20" title="20">{</a>
<a class="sourceLine" id="cb17-21" title="21">    T <span class="fu">Set</span>(T oldObj, TProp newVal);</a>
<a class="sourceLine" id="cb17-22" title="22"></a>
<a class="sourceLine" id="cb17-23" title="23">    T <span class="fu">MultiSet</span>(T oldObj, IEnumerable&lt;TProp&gt; newVals)</a>
<a class="sourceLine" id="cb17-24" title="24">        =&gt; <span class="fu">Set</span>(oldObj, newVals.<span class="fu">Single</span>());</a>
<a class="sourceLine" id="cb17-25" title="25">}</a></code></pre></div>
<p><img src="/images/2018-12-06-zooming-in-on-field-accessors/hierarchy.jpg" width="900" /></p>
<h2 id="default-interface-implementations">Default Interface Implementations</h2>
<p>The code above makes central use of default interface implementations, so it‚Äôs probably time to talk about what they are.</p>
<p>In C#8, interfaces won‚Äôt just be type declarations any more. You‚Äôll be allowed to write code in an interface method, to function as the default implementation of that method. Typically it‚Äôll be written in terms of the other methods on the interface, like an extension method. They differ from extension methods, however, in that they are virtual. If an implementing class has a better (faster, typically) way of implementing the operation, it‚Äôs free to override it.</p>
<p>Here‚Äôs an example. How would LINQ‚Äôs design look different if default interface methods had been around at the time? Today‚Äôs <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.count"><code>Count</code></a> method, an extension method, works in linear time by counting up all of the elements of the input <code>IEnumerable</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">public</span> <span class="kw">static</span> <span class="dt">int</span> Count&lt;T&gt;(<span class="kw">this</span> IEnumerable&lt;T&gt; source)</a>
<a class="sourceLine" id="cb18-2" title="2">{</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="dt">var</span> count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="kw">foreach</span> (<span class="dt">var</span> _ <span class="kw">in</span> source)</a>
<a class="sourceLine" id="cb18-5" title="5">    {</a>
<a class="sourceLine" id="cb18-6" title="6">        count++;</a>
<a class="sourceLine" id="cb18-7" title="7">    }</a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="kw">return</span> count;</a>
<a class="sourceLine" id="cb18-9" title="9">}</a></code></pre></div>
<p>However, there are certain implementations of <code>IEnumerable</code> which can count themselves much faster than that:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">class</span> List&lt;T&gt; : IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb19-2" title="2">{</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="kw">private</span> T[] _array;</a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="kw">private</span> <span class="dt">int</span> _count;</a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="kw">public</span> <span class="dt">int</span> Count =&gt; _count;</a>
<a class="sourceLine" id="cb19-9" title="9">}</a></code></pre></div>
<p><a href="https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Count.cs">The real <code>Count</code> extension method</a> takes a fast path when its argument happens to be an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1?view=netframework-4.7.2"><code>ICollection</code></a>, but that doesn‚Äôt scale well. Not every <code>IEnumerable</code> which admits a fast <code>Count</code> can also implement <code>ICollection</code> ‚Äî for example, an immutable collection can‚Äôt implement the <code>void Add(T item)</code> method.</p>
<p>If LINQ had been designed not as a collection of extension methods but as a collection of default interface methods, it‚Äôd be possible to override <code>Count</code> in an extensible way:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">interface</span> IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb20-2" title="2">{</a>
<a class="sourceLine" id="cb20-3" title="3">    IEnumerator&lt;T&gt; <span class="fu">GetEnumerator</span>();</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5">    <span class="dt">int</span> <span class="fu">Count</span>()</a>
<a class="sourceLine" id="cb20-6" title="6">    {</a>
<a class="sourceLine" id="cb20-7" title="7">        <span class="dt">var</span> count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-8" title="8">        <span class="kw">foreach</span> (<span class="dt">var</span> _ <span class="kw">in</span> source)</a>
<a class="sourceLine" id="cb20-9" title="9">        {</a>
<a class="sourceLine" id="cb20-10" title="10">            count++;</a>
<a class="sourceLine" id="cb20-11" title="11">        }</a>
<a class="sourceLine" id="cb20-12" title="12">        <span class="kw">return</span> count;</a>
<a class="sourceLine" id="cb20-13" title="13">    }</a>
<a class="sourceLine" id="cb20-14" title="14">    <span class="co">// other methods like Select etc</span></a>
<a class="sourceLine" id="cb20-15" title="15">}</a>
<a class="sourceLine" id="cb20-16" title="16"></a>
<a class="sourceLine" id="cb20-17" title="17"><span class="kw">class</span> List&lt;T&gt; : IEnumerable&lt;T&gt;</a>
<a class="sourceLine" id="cb20-18" title="18">{</a>
<a class="sourceLine" id="cb20-19" title="19">    <span class="kw">private</span> T[] _array;</a>
<a class="sourceLine" id="cb20-20" title="20">    <span class="kw">private</span> <span class="dt">int</span> _count;</a>
<a class="sourceLine" id="cb20-21" title="21">    </a>
<a class="sourceLine" id="cb20-22" title="22">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb20-23" title="23"></a>
<a class="sourceLine" id="cb20-24" title="24">    <span class="co">// override the default version from IEnumerable</span></a>
<a class="sourceLine" id="cb20-25" title="25">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">Count</span>() =&gt; _count;</a>
<a class="sourceLine" id="cb20-26" title="26">}</a></code></pre></div>
<p>Interfaces with default methods are somewhat like abstract classes with virtual methods. The main difference is that a class can implement multiple interfaces, while it can only derive from one class. So default interface implementations amount to a form of multiple inheritance! (This provoked much whingeing in <a href="https://github.com/dotnet/csharplang/issues/288">the discussion on GitHub</a>.)</p>
<p>The optics library I‚Äôve outlined above makes central use of multiple inheritance. <code>ILens</code> inherits its <code>MultiGet</code> implementation from <code>IGetter</code> and its <code>Map</code> implementation from <code>IMultiLens</code>. So it wouldn‚Äôt work with abstract classes; before C#8 we wouldn‚Äôt have been able to write this program. Default interface implementations add new expressive power to the language.</p>
<h2 id="production-worthiness">Production-Worthiness</h2>
<p>Lenses are very useful in functional languages, but I would not recommend you use them in practical C#, even after the release of C#8. When you stand it next to <a href="http://hackage.haskell.org/package/lens">Haskell‚Äôs <code>lens</code> library</a>, the API I outlined above has a number of significant shortcomings.</p>
<ul>
<li><p><strong>Performance</strong>. The big one! Accessing a field is such a common operation that it‚Äôd better be fast. The <code>.</code> operator (<code>order.Customer.Address.Postcode</code>) is very fast on the CLR ‚Äî just a pointer hop. Composed lenses, on the other hand, are tree-shaped objects, and calling <code>Get</code> means traversing that tree with a interface method call at each level. I ran some rudimentary benchmarks and found deeply nested lenses to be orders of magnitude slower than equivalent lensless code.</p>
<p>The <code>lens</code> library sidesteps this performance issue by leaning on Haskell‚Äôs optimising compiler. <code>lens</code> has been carefully designed to be easy for GHC to optimise, and the result is that GHC generally produces identical machine code for equivalent lensy and lensless functions.</p></li>
<li><p><strong>Code generation</strong>. Almost all of the atomic lens classes you‚Äôd write for a business system are pure boilerplate ‚Äî exactly the sort of thing you‚Äôd expect a machine to write. You should be able to define an object, perhaps mark it up using an attribute, and get on with using lenses into that object in the rest of your program, with Intellisense support. You shouldn‚Äôt ever need to see a lens‚Äôs source code. Roslyn, the C# compiler, has no facilities for compile-time code injection like this. A lens library could bundle a source code generator, perhaps using Roslyn‚Äôs API, which users run ahead-of-time ‚Äî many ORMs do this ‚Äî but that‚Äôs a much less compelling user experience.</p>
<p>This may be a good use case for F#‚Äôs type providers. (In any case F# places more emphasis on immutability than C#, making lenses a more natural fit in the first place.) Presently you can‚Äôt use a type provider to generate code based on another type (though <a href="https://github.com/fsharp/fslang-design/issues/125">it appears to be planned</a>), and <a href="https://github.com/fsharp/fslang-suggestions/issues/679#issuecomment-399411192">there don‚Äôt seem to be plans</a> to support multiple inheritance in the F# source language. In principle one could implement the hierarchy in C# and consume it from an F# type provider.</p></li>
<li>Two ergonomic complaints regarding C#‚Äôs support for <strong>generics</strong>:
<ul>
<li><p><strong>Type inference</strong>. C# has only minimal support for type inference. This makes generic lenses unpleasant to use. The following lens picks out a <code>KeyValuePair</code>‚Äôs <code>Value</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">class</span> ValueL&lt;K, V&gt; : ILens&lt;KeyValuePair&lt;K, V&gt;, V&gt;</a>
<a class="sourceLine" id="cb21-2" title="2">{</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">public</span> V <span class="fu">Get</span>(KeyValuePair&lt;K, V&gt; kvp) =&gt; kvp.<span class="fu">Value</span>;</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="kw">public</span> KeyValuePair&lt;K, V&gt; <span class="fu">Set</span>(KeyValuePair&lt;K, V&gt; kvp, V val)</a>
<a class="sourceLine" id="cb21-5" title="5">        =&gt; <span class="kw">new</span> KeyValuePair&lt;K, V&gt;(kvp.<span class="fu">Key</span>, val);</a>
<a class="sourceLine" id="cb21-6" title="6">}</a></code></pre></div>
<p>You can‚Äôt use <code>ValueL</code> without explicitly mentioning the concrete type parameters at which you‚Äôre using it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">new</span> ValueL&lt;<span class="dt">string</span>, <span class="dt">int</span>&gt;().<span class="fu">Set</span>(<span class="kw">new</span> KeyValuePair&lt;<span class="dt">string</span>, <span class="dt">int</span>&gt;(<span class="st">&quot;foo&quot;</span>, <span class="dv">3</span>), <span class="dv">7</span>);</a></code></pre></div>
<p>Ideally the compiler would be able to deduce the <code>&lt;string, int&gt;</code> part by noticing that we‚Äôre using it on a <code>KeyValuePair&lt;string, int&gt;</code>. This is difficult to implement in a subtyping-based language, though.</p></li>
<li><p><strong>Generic type aliases</strong>. <a href="http://comonad.com/reader/2012/mirrored-lenses/">The most general formulation of lenses</a> actually has <em>four</em> type parameters: <code>ILens&lt;in S, out T, out A, in B&gt;</code>! This is to support lenses into generic types, allowing you to change the type of the resulting structure by writing a different type into the lens. (<code>new ValueL().Set(new KeyValuePair&lt;string, string&gt;(&quot;foo&quot;, &quot;bar&quot;), 3)</code> should return a <code>KeyValuePair&lt;string, int&gt;</code> ‚Äî that is, a new <code>KeyValuePair</code> with a different type to the original.)</p>
<p>The old <code>ILens&lt;S, A&gt;</code> is then equivalent to <code>ILens&lt;S, S, A, A&gt;</code>. Ideally we‚Äôd be able to define a <em>type alias</em>, so that you can type <code>ILens&lt;S, A&gt;</code> for <code>ILens&lt;S, S, A, A&gt;</code>, but C# doesn‚Äôt support this. (<a href="https://github.com/dotnet/roslyn/issues/3993">A modest proposed extension to <code>using</code></a> would largely service this complaint, reducing the noise to a few lines of boilerplate at the top of each file.)</p></li>
</ul></li>
<li><p><strong>Noisy syntax</strong>. Haskell allows you to define custom symbolic operators, and <code>lens</code> ships a large collection of operators to debigulate your code. <code>new CustomerL()._(new AddressL())._(new PostcodeL()).Get(order)</code> is clunky in comparison to Haskell‚Äôs cute OO-style <code>order^.customer.address.postcode</code>.</p>
<ul>
<li>Related to this concern is <strong>namespacing</strong>. Above I‚Äôve used a convention of appending the letter <code>L</code> to lens classes (<code>CustomerL</code>), but that starts to break down when you have more than one property with the same name in your system. One option might be to nest the lenses inside the objects themselves and import them with <code>using static</code>.</li>
</ul></li>
<li><p><strong>Platform compatibility</strong>. According to <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">a recent announcement</a>, default interface implementations are only going to be available on .NET Core, and won‚Äôt be in the desktop framework for the foreseeable future. As I understand it, the desktop CLR‚Äôs stringent backwards compatibility requirements make testing a wide-reaching CLR feature like this difficult and expensive. But to me, a library author, this is a very disappointing development: libraries <em>must</em> support the desktop CLR if they expect to have any users, so locking down features designed for library authors seems like a misfire. I‚Äôd prefer it if Microsoft just said directly that the desktop framework is being sunsetted ‚Äî that way I‚Äôd at least have some ammunition for GitHub issues.</p></li>
</ul>
<p>All that said, there are a couple of things which I find preferable about this design when compared to <code>lens</code>. Haskell doesn‚Äôt feature subtyping directly, so <code>lens</code> uses a clever function-based encoding of its type hierarchy, using the type class solver to handle the various subtype relationships. Encoding lenses as functions is partly why <code>lens</code> is so fast, but it does make for a steep learning curve and notoriously confusing type errors. Using a more direct representation of subtyping means the model is clearer, and it‚Äôs easier to see how one would slot (eg) prisms or indexed lenses into the system I outlined above. What‚Äôs more, the four-parameter version of <code>ILens</code> I mentioned above is variously co- and contra-variant in its parameters, meaning it interoperates well with the rest of C#‚Äôs type hierarchy. In some sense these lenses are <em>more</em> composable than <code>lens</code>‚Äôs lenses.</p>
<p>I‚Äôd love to tell you I‚Äôve written this up as a published library, but the shortfalls I noted above make this formulation of lenses impractical for real-world use. I‚Äôd love to hear your ideas on how to improve the situation! In the meantime, I bagsie the name <code>OptiCS</code>.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on December  6, 2018</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2018-12-06-zooming-in-on-field-accessors/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Live-streaming</title>
    <link href="http://www.benjamin.pizza/posts/2018-07-16-live-streaming.html" />
    <id>http://www.benjamin.pizza/posts/2018-07-16-live-streaming.html</id>
    <published>2018-07-16T00:00:00Z</published>
    <updated>2018-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 16, 2018
    
</div>

<p>My esteemed colleague <a href="https://twitter.com/g3rv4?lang=en">Gervasio</a> and I have arranged to live-stream some programming <del>this Friday, the 20th of July</del> <strong>Update</strong>: we‚Äôve decided to move it to next <strong>Tuesday, the 24th</strong>, at 2PM BST. We‚Äôre going to be working on adding some basic <code>Span</code> support to <a href="https://github.com/benjamin-hodgson/Pidgin">my parsing library</a>, and it‚Äôs going to involve <code>unsafe</code> and custom IL, which should be a bit of fun.</p>
<p>The stream will be <a href="https://www.youtube.com/watch?v=O23OLkQtiS4">on YouTube</a> and we‚Äôre planning to start at 2PM BST. Hope to see you there with your questions!</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
    </ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Eighty</title>
    <link href="http://www.benjamin.pizza/posts/2018-03-16-eighty.html" />
    <id>http://www.benjamin.pizza/posts/2018-03-16-eighty.html</id>
    <published>2018-03-16T00:00:00Z</published>
    <updated>2018-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 16, 2018
    
</div>

<p>HTML templating systems are great but they sure are complex. ASP.NET‚Äôs Razor, for example, is a whole new programming language! While Razor does happen to have a large chunk of C# embedded within it, and it works by generating and then compiling C# code, it‚Äôs still a separate language with a separate syntax, separate abstraction techniques, separate compiler tooling, a separate file type, and separate (and usually inferior) editor support. All this for a task as simple and common as generating HTML!</p>
<p>This overhead can be worth it if you‚Äôre building a complex web application, but for simple tools such as report generators or email batch mailers Razor is unwieldy. Many people in these situations resort to generating their own HTML, either by building strings manually or by imperatively building tags using .NET‚Äôs supplied XML manipulation APIs. But there‚Äôs a whole world of possible designs out there, and there‚Äôs a lot of space in between ‚Äúcomplex templating language‚Äù and ‚Äúbuild strings by hand‚Äù.</p>
<h2 id="eighty">Eighty</h2>
<p><a href="https://github.com/benjamin-hodgson/Eighty">Eighty</a> (as in <em>eigh-ty-M-L</em>) is my attempt at striking a balance between these two extremes: not so abstract as to constitute a separate programming language, but not so concrete that you have to manipulate XML tags or strings manually. It‚Äôs a simple embedded domain-specific language which piggybacks on C#‚Äôs syntax, enabling you to write code resembling the HTML you‚Äôre generating. Rather than embedding C# into an HTML generator, Eighty embeds an HTML generator into C#.</p>
<p>Here‚Äôs an example from <a href="https://github.com/benjamin-hodgson/Eighty/blob/master/README.md">the readme</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">var</span> html = <span class="fu">article</span>(@class: <span class="st">&quot;readme&quot;</span>)._(</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="fu">h1</span>(id: <span class="st">&quot;Eighty&quot;</span>)._(<span class="st">&quot;Eighty&quot;</span>),</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="fu">p_</span>(</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="st">&quot;Eighty (as in &quot;</span>,</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="fu">i_</span>(<span class="st">&quot;eigh-ty-M-L&quot;</span>),</a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="st">&quot;) is a simple HTML generation library.&quot;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    )</a>
<a class="sourceLine" id="cb1-8" title="8">);</a></code></pre></div>
<p>Eighty is organised around <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.Html.html">the <code>Html</code> class</a>, being an immutable chunk of HTML which knows how to render itself using <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.Html.html#Eighty_Html_Write_System_IO_TextWriter_">its <code>Write(TextWriter)</code> method</a>. <code>Html</code> defines a large collection of static methods (designed to be imported with <code>using static</code>), with names like <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.Html.html#Eighty_Html_h1_System_String_System_String_System_String_System_String_System_String_System_String_"><code>h1</code></a> and <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.Html.html#Eighty_Html_p_System_String_System_String_System_String_System_String_System_String_System_String_"><code>p</code></a>, which create <code>Html</code> values representing their respective tags, with a collection of children which are smaller <code>Html</code> values.</p>
<p>Eighty adopts some simple conventions for its HTML-esque domain-specific language:</p>
<ul>
<li>Tags are created using (lower-case) methods like <code>p()</code> and <code>i()</code>.</li>
<li>Attributes are passed as optional named arguments: <code>a(href: &quot;benjamin.pizza&quot;, @class: &quot;website-link&quot;)</code>. I can‚Äôt force you to name your arguments ‚Äî you could pass them positionally ‚Äî but that‚Äôs not a good idea.</li>
<li>A tag‚Äôs children are introduced using the <code>_</code> character, which can appear at the end of a method name or as a method name all by itself. <code>a(href: &quot;benjamin.pizza&quot;)._(&quot;Visit my website&quot;)</code> creates an <code>a</code> tag with an <code>href</code> attribute and some text inside it; <code>p_(&quot;a paragraph of text&quot;)</code> represents a <code>p</code> tag with some text but no attributes. I chose <code>_</code> because it‚Äôs the least noisy character that can be used as an identifier in C#.</li>
<li>Strings can be implicitly converted to <code>Html</code> and are interpreted as HTML text. Text is HTML-encoded by default. You can opt out of this using the <code>Raw</code> method.</li>
</ul>
<h2 id="eighty-vs-razor">Eighty vs Razor</h2>
<p>Of course, C# code will only ever look <em>a bit</em> like HTML. Razor code looks much more like HTML than this! This can be a drawback when you‚Äôre working with designers who want to read and write HTML ‚Äî I‚Äôm planning to write a tool to convert HTML text into an Eighty expression to partially ease this pain point. But Eighty has two big advantages which make it simpler and easier than Razor to program with:</p>
<ol type="1">
<li>It plugs into your existing system. You don‚Äôt require any extra tools to work with Eighty: if you can compile C#, you can use Eighty.</li>
<li>Programming with Eighty is <em>just programming</em>. <code>Html</code> instances are plain old immutable CLR objects, so you can use all your favourite techniques for abstraction and code reuse.</li>
</ol>
<p>To illustrate the second point, here are some examples of how you might emulate some of Razor‚Äôs programming constructs using Eighty. In many of these cases Eighty does a better job than Razor of allowing abstraction and code reuse, because Eighty is embedded within C# rather than layered on top of C#.</p>
<h3 id="models">Models</h3>
<p>In Razor, each view file you write declares a <em>model type</em> ‚Äî the type of object it expects you to pass in to direct the generation of HTML. You use the <code>@model</code> directive at the top of your file, and then you can access members of the model in your Razor code.</p>
<pre class="cshtml"><code>@model ExampleModel

&lt;h1&gt;@Model.Title&lt;/h1&gt;</code></pre>
<p>One important disadvantage of Razor‚Äôs <code>@model</code> construct is that it is dynamically checked. The controller‚Äôs <code>View</code> method takes an <code>object</code> for the <code>model</code> parameter. You get a runtime error, without any feedback from the compiler, if you pass in a model whose type doesn‚Äôt match the view‚Äôs expected model type.</p>
<p>Since Eighty is embedded within C#, there‚Äôs no special syntax to declare the type of data a function depends on. You can just use a plain old parameter.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb3-1" title="1">Html <span class="fu">Example</span>(ExampleModel model)</a>
<a class="sourceLine" id="cb3-2" title="2">    =&gt; <span class="fu">h1_</span>(model.<span class="fu">Title</span>);</a></code></pre></div>
<p>Since a template is a regular C# method, it‚Äôs much easier to run in a unit test harness than Razor. You can just call the method and make assertions about the generated HTML, either by looking at the string directly or by parsing it and traversing the resultant DOM.</p>
<p>Eighty includes <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.IHtmlRenderer-1.html">an <code>IHtmlRenderer&lt;TModel&gt;</code> interface</a>, which captures this pattern of parameterising a chunk of HTML by a model, but its use is optional ‚Äî it‚Äôs used primarily by Eighty‚Äôs ASP.NET integration packages.</p>
<h3 id="control-flow">Control flow</h3>
<p>Razor allows you to mix markup with C#‚Äôs control flow constructs such as <code>foreach</code> and <code>if</code>. Here‚Äôs a simple example of populating a <code>ul</code> based on a list of values:</p>
<pre class="cshtml"><code>&lt;ul&gt;
    @foreach (var item in Model.Items)
    {
        if (item.Visible)
        {
            &lt;li&gt;@item.Value&lt;/li&gt;
        }
    }
&lt;/ul&gt;</code></pre>
<p>With Eighty, it‚Äôs a question of building different <code>Html</code> values. You can use LINQ‚Äôs high-level functional looping constructs:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">return</span> <span class="fu">ul_</span>(</a>
<a class="sourceLine" id="cb5-2" title="2">    model.<span class="fu">Items</span></a>
<a class="sourceLine" id="cb5-3" title="3">        .<span class="fu">Where</span>(item =&gt; item.<span class="fu">Visible</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">        .<span class="fu">Select</span>(item =&gt; <span class="fu">li_</span>(item.<span class="fu">Value</span>))</a>
<a class="sourceLine" id="cb5-5" title="5">);</a></code></pre></div>
<p>Or you can write your own loop and build a list:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">var</span> lis = <span class="kw">new</span> List&lt;Html&gt;();</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">foreach</span> (<span class="dt">var</span> item <span class="kw">in</span> model.<span class="fu">Items</span>)</a>
<a class="sourceLine" id="cb6-3" title="3">{</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="kw">if</span> (item.<span class="fu">Visible</span>)</a>
<a class="sourceLine" id="cb6-5" title="5">    {</a>
<a class="sourceLine" id="cb6-6" title="6">        lis.<span class="fu">Add</span>(<span class="fu">li_</span>(item.<span class="fu">Value</span>));</a>
<a class="sourceLine" id="cb6-7" title="7">    }</a>
<a class="sourceLine" id="cb6-8" title="8">}</a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">return</span> <span class="fu">ul_</span>(lis);</a></code></pre></div>
<p>Mixing markup with C# is not a problem, because markup <em>is</em> C#.</p>
<h3 id="partials-and-helpers">Partials and Helpers</h3>
<p>Razor‚Äôs two main tools for code reuse are <em>partial views</em> and <em>helpers</em>. For the purposes of this article, they‚Äôre roughly equivalent. Partial views can be returned directly from a controller but their model type is checked at runtime, whereas helpers‚Äô parameters are checked by the compiler but they can only be invoked from within a Razor view.</p>
<p>Eighty handles both of these uses in the simplest of ways: <em>calling a function</em>. If I want to include an HTML snippet in more than one place, I can just extract it into a method returning an <code>Html</code> object. Transliterating an example from <a href="https://docs.microsoft.com/en-us/aspnet/web-pages/overview/ui-layouts-and-themes/creating-and-using-a-helper-in-an-aspnet-web-pages-site">the MVC documentation</a>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb7-1" title="1">Html <span class="fu">MakeNote</span>(<span class="dt">string</span> content)</a>
<a class="sourceLine" id="cb7-2" title="2">    =&gt; <span class="fu">div</span>(@class: <span class="st">&quot;note&quot;</span>)._(</a>
<a class="sourceLine" id="cb7-3" title="3">        <span class="fu">p_</span>(</a>
<a class="sourceLine" id="cb7-4" title="4">            <span class="fu">strong_</span>(<span class="st">&quot;Note&quot;</span>),</a>
<a class="sourceLine" id="cb7-5" title="5">            <span class="fu">Raw</span>(<span class="st">&quot;&amp;nbsp;&amp;nbsp; &quot;</span>),</a>
<a class="sourceLine" id="cb7-6" title="6">            content</a>
<a class="sourceLine" id="cb7-7" title="7">        )</a>
<a class="sourceLine" id="cb7-8" title="8">    );</a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10">Html <span class="fu">SomeHtmlContainingANote</span>()</a>
<a class="sourceLine" id="cb7-11" title="11">    =&gt; <span class="fu">article_</span>(</a>
<a class="sourceLine" id="cb7-12" title="12">        <span class="fu">p_</span>(<span class="st">&quot;This is some opening paragraph text&quot;</span>),</a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="fu">MakeNote</span>(<span class="st">&quot;My test note content&quot;</span>),</a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="fu">p_</span>(<span class="st">&quot;This is some following text&quot;</span>)</a>
<a class="sourceLine" id="cb7-15" title="15">    );</a></code></pre></div>
<p>This is the best of both worlds: types are checked by the compiler as usual, but the returned <code>Html</code> value is a perfectly good standalone chunk of HTML, and can be rendered separately if necessary.</p>
<p><code>Html</code> values being ordinary C# values, Eighty actually supports more types of reuse than Razor does. For example, you can pass a chunk of HTML as an argument, which is not easy to do with Razor:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb8-1" title="1">Html <span class="fu">RepeatFiveTimes</span>(Html html)</a>
<a class="sourceLine" id="cb8-2" title="2">    =&gt; <span class="fu">_</span>(Enumerable.<span class="fu">Repeat</span>(html, <span class="dv">5</span>));</a></code></pre></div>
<p>Since <code>Html</code> values are immutable, you can safely share them between different HTML documents, across different threads, etc. Sharing parts of your HTML document that don‚Äôt change can be an important optimisation.</p>
<h3 id="layouts">Layouts</h3>
<p>Razor lets you define a shared <em>layout</em> page, which acts as a template for the other pages in your application. For example, you might put the <code>html</code> and <code>body</code> tags in a layout page, and use the built in <code>RenderBody</code> helper to render the concrete page‚Äôs body inside the <code>body</code> tag. This is also where global navs and the like are defined.</p>
<p>One way to handle global layouts and sections in Eighty would be to define an abstract base class. Each section becomes an abstract method, allowing individual pages to fill in their own HTML for those sections.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">abstract</span> <span class="kw">class</span> Layout</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">public</span> Html <span class="fu">GetHtml</span>()</a>
<a class="sourceLine" id="cb9-4" title="4">        =&gt; <span class="fu">doctypeHtml_</span>(</a>
<a class="sourceLine" id="cb9-5" title="5">            <span class="fu">head</span>(</a>
<a class="sourceLine" id="cb9-6" title="6">                <span class="fu">link</span>(</a>
<a class="sourceLine" id="cb9-7" title="7">                    rel: <span class="st">&quot;stylesheet&quot;</span>,</a>
<a class="sourceLine" id="cb9-8" title="8">                    type: <span class="st">&quot;text/css&quot;</span>,</a>
<a class="sourceLine" id="cb9-9" title="9">                    href: <span class="st">&quot;default.css&quot;</span></a>
<a class="sourceLine" id="cb9-10" title="10">                ),</a>
<a class="sourceLine" id="cb9-11" title="11">                <span class="fu">Css</span>(),</a>
<a class="sourceLine" id="cb9-12" title="12">                <span class="fu">script</span>(</a>
<a class="sourceLine" id="cb9-13" title="13">                    type: <span class="st">&quot;text/javascript&quot;</span>,</a>
<a class="sourceLine" id="cb9-14" title="14">                    src: <span class="st">&quot;jquery-3.3.1.min.js&quot;</span></a>
<a class="sourceLine" id="cb9-15" title="15">                ),</a>
<a class="sourceLine" id="cb9-16" title="16">                <span class="fu">Js</span>()</a>
<a class="sourceLine" id="cb9-17" title="17">            ),</a>
<a class="sourceLine" id="cb9-18" title="18">            <span class="fu">body</span>(</a>
<a class="sourceLine" id="cb9-19" title="19">                <span class="fu">Body</span>()</a>
<a class="sourceLine" id="cb9-20" title="20">            )</a>
<a class="sourceLine" id="cb9-21" title="21">        );</a>
<a class="sourceLine" id="cb9-22" title="22"></a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="kw">protected</span> <span class="kw">abstract</span> Html <span class="fu">Css</span>();</a>
<a class="sourceLine" id="cb9-24" title="24">    <span class="kw">protected</span> <span class="kw">abstract</span> Html <span class="fu">Js</span>();</a>
<a class="sourceLine" id="cb9-25" title="25">    <span class="kw">protected</span> <span class="kw">abstract</span> Html <span class="fu">Body</span>();</a>
<a class="sourceLine" id="cb9-26" title="26">}</a></code></pre></div>
<p>Then, inheriting a layout is as easy as inheriting a class.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">class</span> DashboardPage : Layout</a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="kw">private</span> DashboardModel _model;</a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">public</span> <span class="fu">Dashboard</span>(DashboardModel model)</a>
<a class="sourceLine" id="cb10-6" title="6">    {</a>
<a class="sourceLine" id="cb10-7" title="7">        _model = model;</a>
<a class="sourceLine" id="cb10-8" title="8">    }</a>
<a class="sourceLine" id="cb10-9" title="9"></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="kw">protected</span> <span class="kw">override</span> Html <span class="fu">Css</span>()</a>
<a class="sourceLine" id="cb10-11" title="11">        =&gt; <span class="co">/* Dashboard-specific CSS */</span>;</a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="kw">protected</span> <span class="kw">override</span> Html <span class="fu">Js</span>()</a>
<a class="sourceLine" id="cb10-14" title="14">        =&gt; <span class="co">/* Dashboard-specific scripts */</span>;</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="kw">protected</span> <span class="kw">override</span> Html <span class="fu">Body</span>()</a>
<a class="sourceLine" id="cb10-17" title="17">        =&gt; <span class="co">/* The body of the dashboard page */</span>;</a>
<a class="sourceLine" id="cb10-18" title="18">}</a></code></pre></div>
<h2 id="twenty">Twenty</h2>
<p>Eighty comes bundled with a second HTML generation library called Twenty. Twenty is harder to use correctly than Eighty, and its API is more verbose, but it‚Äôs faster.</p>
<p>HTML tags have to be balanced: every opening tag has to have a matching closing tag and vice versa. While an <code>Html</code> value is being written to a <code>TextWriter</code>, Eighty manages the stack of currently-open tags using the call stack. Each tag writes its opening tag, tells its children to write themselves, and then writes its closing tag. This is possible because <code>Html</code> is an ordinary reference type; the objects you build with methods like <code>p()</code> and <code>h1()</code> are tree-shaped objects representing a DOM of statically-unknown size.</p>
<p>Twenty instead takes an imperative view of HTML generation. Each tag method writes an opening tag to the <code>TextWriter</code> immediately, and returns an <code>IDisposable</code> which writes out the closing tag when it‚Äôs disposed. You, the programmer, use C#‚Äôs <code>using</code> statement to ensure that the <code>Dispose</code> method is called as soon as the children have been written. The structure of your HTML document is still visible in the code, but it‚Äôs present in the nesting of <code>using</code> statements, rather than by the structure of a tree-shaped object.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">class</span> MyHtmlBuilder : HtmlBuilder</a>
<a class="sourceLine" id="cb11-2" title="2">{</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">protected</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Build</span>()</a>
<a class="sourceLine" id="cb11-4" title="4">    {</a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="kw">using</span> (<span class="fu">article</span>(@class: <span class="st">&quot;readme&quot;</span>))</a>
<a class="sourceLine" id="cb11-6" title="6">        {</a>
<a class="sourceLine" id="cb11-7" title="7">            <span class="kw">using</span> (<span class="fu">h1</span>(id: <span class="st">&quot;Eighty&quot;</span>))</a>
<a class="sourceLine" id="cb11-8" title="8">                <span class="fu">Text</span>(<span class="st">&quot;Eighty&quot;</span>);</a>
<a class="sourceLine" id="cb11-9" title="9">            <span class="kw">using</span> (<span class="fu">p</span>())</a>
<a class="sourceLine" id="cb11-10" title="10">            {</a>
<a class="sourceLine" id="cb11-11" title="11">                <span class="fu">Text</span>(<span class="st">&quot;Eighty (as in &quot;</span>);</a>
<a class="sourceLine" id="cb11-12" title="12">                <span class="kw">using</span> (<span class="fu">i</span>())</a>
<a class="sourceLine" id="cb11-13" title="13">                    <span class="fu">Text</span>(<span class="st">&quot;eigh-ty-M-L&quot;</span>);</a>
<a class="sourceLine" id="cb11-14" title="14">                <span class="fu">Text</span>(<span class="st">&quot;) is a simple HTML generation library.&quot;</span>);</a>
<a class="sourceLine" id="cb11-15" title="15">            }</a>
<a class="sourceLine" id="cb11-16" title="16">        }</a>
<a class="sourceLine" id="cb11-17" title="17">    }</a>
<a class="sourceLine" id="cb11-18" title="18">}</a></code></pre></div>
<p>Perhaps this is a bit of an abuse of <code>IDisposable</code>, and the <code>using</code> syntax is comparatively noisy, but this trick allows Twenty to operate quickly and without generating any garbage while still making for a reasonable DSL. Compared to Eighty, Twenty does lose out on some flexibility and safety:</p>
<ul>
<li>You mustn‚Äôt forget a <code>using</code> statement, or call <code>Dispose</code> more than once, or Twenty will output malformed HTML. Eighty, on the other hand, will never generate bad HTML (notwithstanding the use of <code>Raw</code>).</li>
<li>There‚Äôs no <code>Html</code> object ‚Äî you can‚Äôt pass around chunks of HTML as first class values. This makes code reuse and abstraction somewhat more difficult.</li>
<li><code>HtmlBuilder</code> is not re-entrant. You can‚Äôt use the same <code>HtmlBuilder</code> from multiple threads.</li>
<li>There‚Äôs no <code>async</code> API, because there‚Äôs no way to call <code>Dispose</code> asynchronously.</li>
</ul>
<p>Given Twenty‚Äôs limitations, my advice is to write your markup using <code>Html</code>, and convert it to <code>HtmlBuilder</code> if you see that building <code>Html</code> values is a performance bottleneck.</p>
<h2 id="performance">Performance</h2>
<p>Eighty is pretty fast. I wrote a benchmark testing how long it takes to spit out around 30kB of HTML (with some encoding characters thrown in for good measure) while running in an in-memory hosted MVC application. Eighty‚Äôs synchronous code path does this around three times faster than Razor, and Twenty runs about 30% faster than that ‚Äî so, four times faster than Razor.</p>
<p>What have I done to make Eighty fast? Honestly, not a huge amount. There are a only few interesting optimisations in Eighty‚Äôs codebase.</p>
<ul>
<li>Each call to <code>TextWriter</code>‚Äôs <code>Write</code> method is comparatively expensive, so rather than write individual snippets of HTML into the <code>TextWriter</code> directly, Eighty builds up a 4kB buffer and empties it out into the <code>TextWriter</code> when it fills up. The code to fill this buffer is a little fiddly, because you don‚Äôt know how long your input string is going to be after HTML-encoding it, so the HTML encoder has to write the encoded HTML in chunks. I toyed with a hand-written encoder, but I wanted to interoperate with ASP.NET‚Äôs pluggable <code>HtmlEncoder</code>, so I ended up calling that class‚Äôs low-level API.
<ul>
<li>The buffer is managed by <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/HtmlEncodingTextWriter.cs">a mutable struct</a> which is <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/Html.cs#L61-L63">stored on the stack and passed by reference</a> because mutable structs must never be copied. However, <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/AsyncHtmlEncodingTextWriter.cs">the async version</a> <em>cannot</em> be a struct because <code>async</code> methods copy their <code>this</code> variable into a field behind the scenes. My first version of the code used the same mutable struct for both paths, which caused me some head-scratching when the <code>async</code> version didn‚Äôt work!</li>
<li>There‚Äôs <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/Twenty/HtmlEncodingTextWriterReference.cs">a fun and dangerous hack</a> in Twenty‚Äôs codebase to allow storing a reference to one of these stack-allocated structs <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/Twenty/HtmlBuilder.cs">in a field</a>. This is safe as long as the reference in the field doesn‚Äôt live longer than the stack location to which it refers, but you don‚Äôt get any compile-time feedback about this (I just have to program carefully and hope I don‚Äôt make a mistake). This hack makes critical use of C# 7‚Äôs ‚Äú<code>ref</code> return types‚Äù, so it wouldn‚Äôt have been possible a couple of years ago.</li>
</ul></li>
<li>Calling an <code>async</code> method is comparatively expensive, even if it never goes async, because of the way <code>async</code> methods are translated by the compiler into code which builds and then executes a state machine. In the case of Eighty‚Äôs frequently-called <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/AsyncHtmlEncodingTextWriter.cs#L149"><code>WriteRawImpl</code> method</a>, it‚Äôs predictable whether a call will complete synchronously (that is, without calling the underlying <code>TextWriter</code>‚Äôs <code>WriteAsync</code> method). <a href="https://github.com/benjamin-hodgson/Eighty/commit/1d6b5f45919363c978de05a5a849835cec6a773b#diff-c3aed398c4361803494b9d59237185e2">I split the <code>async</code> method into two parts</a> ‚Äî a fast wrapper which synchronously returns a <code>Task</code> and an <code>async</code> method which is only called when necessary ‚Äî and got a ~15% speedup in my end-to-end benchmarks.</li>
<li><code>Html</code> values make use of <code>ImmutableArray</code>s to store their children. <code>ImmutableArray</code> is a thin wrapper over a regular array, so if you have a <code>T[]</code> you should be able to turn it into an <code>ImmutableArray</code> in-place without copying the contents, as long as you‚Äôre careful never to modify the original array after freezing it. There are several places in Eighty where this is a safe optimisation, but <code>ImmutableArray</code> doesn‚Äôt have a public API to do this. However, since <code>ImmutableArray&lt;T&gt;</code> is a struct with a single private <code>T[]</code> field, its runtime representation is the same as <code>T[]</code>‚Äôs. This makes it possible to <a href="https://github.com/benjamin-hodgson/Eighty/blob/3c431c13200022bb34ee3de635cce305384abef5/Eighty/ImmutableArrayFactory.cs#L45">unsafely coerce a <code>T[]</code> to an <code>ImmutableArray&lt;T&gt;</code></a> with no runtime cost.
<ul>
<li>I‚Äôve opened <a href="https://github.com/dotnet/corefx/issues/28064">an issue in the <code>corefx</code> repo</a> proposing an officially-supported API for this use case.</li>
</ul></li>
</ul>
<p>I‚Äôm not sure exactly why Razor is slower by comparison. My guess is that Razor‚Äôs template compiler just tends to generate comparatively slow C# code ‚Äî so there‚Äôs probably some room for improvement ‚Äî but I would like to investigate this more.</p>
<hr />
<p>HTML generators are an example of a problem where the spectrum of possible solutions is very broad indeed. Just within the C# ecosystem there exists a menagerie of different templating languages, as well as imperative object-oriented APIs like <code>TagBuilder</code> and streaming APIs like <code>XmlWriter</code>. Even Eighty and Twenty, two implementations of the same idea, are substantially different. You can often find yourself somewhere quite interesting if you appreach a common problem from a different direction than the established solutions. What parts of the library ecosystem do you think you could do with a fresh perspective?</p>
<p>Eighty is available <a href="https://www.nuget.org/packages/Eighty">on Nuget</a>, along with some helpers to integrate Eighty with <a href="https://www.nuget.org/packages/Eighty.AspNet.Mvc">MVC</a> and <a href="https://www.nuget.org/packages/Eighty.AspNetCore">ASP.NET Core</a>. API docs are hosted <a href="https://www.benjamin.pizza/Eighty/v1.2.0/api/Eighty.html">on this very domain</a>, and the code‚Äôs all <a href="https://github.com/benjamin-hodgson/Eighty">on GitHub</a> where contributions and bug reports are very welcome!</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on March 16, 2018</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2018-03-16-eighty/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Zip-Folding</title>
    <link href="http://www.benjamin.pizza/posts/2018-01-10-zip-folding.html" />
    <id>http://www.benjamin.pizza/posts/2018-01-10-zip-folding.html</id>
    <published>2018-01-10T00:00:00Z</published>
    <updated>2018-01-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 10, 2018
    
</div>

<p>One of my favourite little gems of functional programming is the following implementation of the dot product:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">dot ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb1-2" title="2">xs <span class="ot">`dot`</span> ys <span class="fu">=</span> <span class="fu">sum</span> (<span class="fu">zipWith</span> (<span class="fu">*</span>) xs ys)</a></code></pre></div>
<p><code>dot</code> zips two lists of numbers, multiplying each pair of elements using <code>(*)</code>, and then aggregates the results with <code>sum</code>. It‚Äôs like a <em>map-reduce</em> program, but it processes two collections, not one. It generalises rather beautifully to any zippily <code>Applicative</code> <code>Foldable</code> container whose elements form a <code>Semiring</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">dot ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">xs <span class="ot">`dot`</span> ys <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;+&gt;</span>) zero (liftA2 (<span class="fu">&lt;.&gt;</span>) xs ys)</a></code></pre></div>
<p>I think I‚Äôm particularly taken with this example because it combines three different abstractions in a totally natural way to produce a concise and generic implementation of a well-known program. It‚Äôs a beautiful demonstration of how these mathematical tools fit together. It also happens to be an example of a programming pattern that I call <em>zip-folding</em>.</p>
<hr />
<p>Until recently I felt rather embarrassed that my C# generic programming library <a href="https://github.com/benjamin-hodgson/Sawmill">Sawmill</a> didn‚Äôt have a good story for consuming more than one tree at a time. I had lots of tools for <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.SelfAndDescendants.cs">querying</a>, <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Rewrite.cs">editing</a>, and <a href="https://github.com/benjamin-hodgson/Sawmill/blob/b87687e67185ddc299ad67455bd7c79f97e066b2/Sawmill/Rewriter.Fold.cs">tearing down</a> single trees, but nothing that could help you process two trees at once. This is a very common requirement - for example, if you‚Äôre unit testing a parser or a transformation pass, you need to compare the output tree to the one that you expected.</p>
<p>I got to thinking about what it means to zip two trees together - an operation which should make sense if you think of a tree as a container of subtrees. Pairing up nodes in a tree is straightforward, even if the two trees are unevenly shaped. You just pair up the children of each pair of nodes, ignoring those which don‚Äôt have a partner (the grey-coloured ones in the drawing):</p>
<p><img src="/images/2018-01-10-zip-folding/zip.jpg" alt="Pairing up nodes" width="900" /></p>
<p>But I got stuck on how to plug those paired nodes back into a single tree representing the zipped trees. Nodes typically have space for a fixed number of children, but pairing up children will typically change that number. That is, a binary operator has precisely two children, but when zipping two binary operators together you need to do something with four children.</p>
<p>And, more generally, what would it mean to zip trees recursively? You can imagine a scheme wherein each child of a node is replaced with a tuple of two children. But each child is really a subtree, with its own children, so the two subtrees need to be zipped - but that ought to produce a single tree, not a pair of trees. It‚Äôs contradictory! The intuitive idea that a node in a tree is a container of subtrees fails when you consider zipping.</p>
<hr />
<p>Guess where this is going: you can‚Äôt <em>zip</em> trees to produce a new tree, but you can <em>zip-fold</em> trees to produce a value. The idea is to take pairs of nodes in a tree and combine them with the results of zipping their children.</p>
<p>Let‚Äôs start by looking at (an abbreviated version of) Sawmill‚Äôs existing <code>Fold</code>. <code>Fold</code> says <em>if you give me a way to combine a node with the results of folding its children, I can recursively fold the entire tree to produce a single summary value</em>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">public</span> <span class="kw">static</span> U Fold&lt;T, U&gt;(</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">this</span> T value,</a>
<a class="sourceLine" id="cb3-3" title="3">    Func&lt;T, Children&lt;U&gt;, U&gt; func,</a>
<a class="sourceLine" id="cb3-4" title="4">) where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb3-5" title="5">    =&gt; <span class="fu">func</span>(</a>
<a class="sourceLine" id="cb3-6" title="6">        value,</a>
<a class="sourceLine" id="cb3-7" title="7">        value.<span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb3-8" title="8">            .<span class="fu">Select</span>(child =&gt; child.<span class="fu">Fold</span>(func))</a>
<a class="sourceLine" id="cb3-9" title="9">    );</a></code></pre></div>
<p>Revisiting <a href="https://www.benjamin.pizza/posts/2017-11-13-recursion-without-recursion.html">the JQL example</a>, <code>Fold</code> will take an input tree like <code>[c#] and (not [javascript] or salary:50000gbp)</code> and compute the expression:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">func</span>(</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">new</span> <span class="fu">AndNode</span>(<span class="co">/* ... */</span>),</a>
<a class="sourceLine" id="cb4-3" title="3">    Children.<span class="fu">Two</span>(</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="fu">func</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;c#&quot;</span>), Children.<span class="fu">None</span>&lt;U&gt;()),</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="fu">func</span>(</a>
<a class="sourceLine" id="cb4-6" title="6">            <span class="kw">new</span> <span class="fu">OrNode</span>(<span class="co">/* ... */</span>),</a>
<a class="sourceLine" id="cb4-7" title="7">            Children.<span class="fu">Two</span>(</a>
<a class="sourceLine" id="cb4-8" title="8">                <span class="fu">func</span>(</a>
<a class="sourceLine" id="cb4-9" title="9">                    <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="co">/* ... */</span>),</a>
<a class="sourceLine" id="cb4-10" title="10">                    Children.<span class="fu">One</span>(</a>
<a class="sourceLine" id="cb4-11" title="11">                        <span class="fu">func</span>(</a>
<a class="sourceLine" id="cb4-12" title="12">                            <span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>),</a>
<a class="sourceLine" id="cb4-13" title="13">                            Children.<span class="fu">None</span>&lt;U&gt;()</a>
<a class="sourceLine" id="cb4-14" title="14">                        )</a>
<a class="sourceLine" id="cb4-15" title="15">                    )</a>
<a class="sourceLine" id="cb4-16" title="16">                ),</a>
<a class="sourceLine" id="cb4-17" title="17">                <span class="fu">func</span>(<span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>), Children.<span class="fu">None</span>&lt;U&gt;())</a>
<a class="sourceLine" id="cb4-18" title="18">            )</a>
<a class="sourceLine" id="cb4-19" title="19">        )</a>
<a class="sourceLine" id="cb4-20" title="20">    )</a>
<a class="sourceLine" id="cb4-21" title="21">)</a></code></pre></div>
<p><code>Fold</code> traverses a tree from bottom to top, applying <code>func</code> to each subtree and the current set of intermediate results.</p>
<p><code>ZipFold</code> works by analogy to <code>Fold</code>. It says <em>if you give me a way to combine two nodes with the results of zip-folding their children, I can recursively zip the two entire trees to produce a single summary value</em>. <code>ZipFold</code> pairs up the children of the two input nodes using the standard <code>Enumerable.Zip</code>, recursively zip-folds each pair, and then feeds the results to <code>func</code>. Note that the length of the <code>IEnumerable</code> that‚Äôs passed to <code>func</code> is the length of the smaller of the two nodes‚Äô collections of children.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">public</span> <span class="kw">static</span> U ZipFold&lt;T, U&gt;(</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">this</span> T value1,</a>
<a class="sourceLine" id="cb5-3" title="3">    T value2</a>
<a class="sourceLine" id="cb5-4" title="4">    Func&lt;T, T, IEnumerable&lt;U&gt;, U&gt; zipFunc,</a>
<a class="sourceLine" id="cb5-5" title="5">) where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb5-6" title="6">    =&gt; <span class="fu">zipFunc</span>(</a>
<a class="sourceLine" id="cb5-7" title="7">        value1,</a>
<a class="sourceLine" id="cb5-8" title="8">        value2,</a>
<a class="sourceLine" id="cb5-9" title="9">        value1.<span class="fu">GetChildren</span>().<span class="fu">Zip</span>(</a>
<a class="sourceLine" id="cb5-10" title="10">            value2.<span class="fu">GetChildren</span>(),</a>
<a class="sourceLine" id="cb5-11" title="11">            (child1, child2) =&gt; child1.<span class="fu">ZipFold</span>(child2, zipFunc)</a>
<a class="sourceLine" id="cb5-12" title="12">        )</a>
<a class="sourceLine" id="cb5-13" title="13">    );</a></code></pre></div>
<p>The two trees are zipped together and torn down in a single pass.</p>
<p>Here‚Äôs how it looks in Haskell, using the <a href="https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html"><code>Control.Lens.Plated</code></a> API. Haskellers like to use tongue-in-cheek Greek names for recursion schemes. Apparently the Greek word for ‚Äúzip‚Äù is ‚Äúfermou√°r‚Äù, so I‚Äôm calling this a <em>fermomorphism</em>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">fermo ::</span> <span class="dt">Plated</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb6-2" title="2">fermo f x y <span class="fu">=</span> f x y <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="fu">zipWith</span> (fermo f) (toListOf plate x) (toListOf plate y)</a></code></pre></div>
<p>As an example: <code>ZipFold</code> allows you to concisely test a pair of trees for equality, by looking only at one pair of nodes at a time.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">public</span> <span class="kw">static</span> <span class="dt">bool</span> <span class="fu">Equal</span>(JqlNode j1, JqlNode j2)</a>
<a class="sourceLine" id="cb7-2" title="2">    =&gt; j1.<span class="fu">ZipFold</span>&lt;JqlNode, <span class="dt">bool</span>&gt;(</a>
<a class="sourceLine" id="cb7-3" title="3">        j2,</a>
<a class="sourceLine" id="cb7-4" title="4">        (n1, n2, childrenEqual) =&gt;</a>
<a class="sourceLine" id="cb7-5" title="5">        {</a>
<a class="sourceLine" id="cb7-6" title="6">            <span class="kw">switch</span> (n1)</a>
<a class="sourceLine" id="cb7-7" title="7">            {</a>
<a class="sourceLine" id="cb7-8" title="8">                <span class="kw">case</span> SalaryNode s1 when n2 <span class="kw">is</span> SalaryNode s2:</a>
<a class="sourceLine" id="cb7-9" title="9">                    <span class="kw">return</span> s1.<span class="fu">Currency</span> == s2.<span class="fu">Currency</span></a>
<a class="sourceLine" id="cb7-10" title="10">                        &amp;&amp; s1.<span class="fu">Amount</span> == s2.<span class="fu">Amount</span>;</a>
<a class="sourceLine" id="cb7-11" title="11">                <span class="kw">case</span> TagNode t1 when n2 <span class="kw">is</span> TagNode t2:</a>
<a class="sourceLine" id="cb7-12" title="12">                    <span class="kw">return</span> t1.<span class="fu">Tag</span> == t2.<span class="fu">Tag</span>;</a>
<a class="sourceLine" id="cb7-13" title="13">                <span class="kw">case</span> AndNode a1 when n2 <span class="kw">is</span> AndNode a2:</a>
<a class="sourceLine" id="cb7-14" title="14">                <span class="kw">case</span> OrNode o1 when n2 <span class="kw">is</span> OrNode o2:</a>
<a class="sourceLine" id="cb7-15" title="15">                <span class="kw">case</span> NotNode a1 when n2 <span class="kw">is</span> NotNode a2:</a>
<a class="sourceLine" id="cb7-16" title="16">                    <span class="kw">return</span> childrenEqual.<span class="fu">All</span>(c =&gt; c);</a>
<a class="sourceLine" id="cb7-17" title="17">                <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb7-18" title="18">                    <span class="kw">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb7-19" title="19">            }</a>
<a class="sourceLine" id="cb7-20" title="20">        }</a>
<a class="sourceLine" id="cb7-21" title="21">    );</a></code></pre></div>
<p>The <code>ZipFold</code> that you‚Äôll find in Sawmill is actually an <em>n</em>-ary zip-fold. Instead of taking two <code>T</code>s, and passing two <code>T</code>s to <code>func</code>, it works with an arbitrary number of <code>T</code>s. Here‚Äôs the code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">public</span> <span class="kw">static</span> U ZipFold&lt;T, U&gt;(</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">this</span> T[] values,</a>
<a class="sourceLine" id="cb8-3" title="3">    Func&lt;T[], IEnumerable&lt;U&gt;, U&gt; func,</a>
<a class="sourceLine" id="cb8-4" title="4">) where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb8-5" title="5">    =&gt; <span class="fu">func</span>(values, xs.<span class="fu">ZipChildren</span>(children =&gt; children.<span class="fu">ZipFold</span>(func)));</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">private</span> <span class="kw">static</span> IEnumerable&lt;U&gt; ZipChildren&lt;T, U&gt;(</a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="kw">this</span> T[] input,</a>
<a class="sourceLine" id="cb8-9" title="9">    Func&lt;T[], U&gt; zipFunc</a>
<a class="sourceLine" id="cb8-10" title="10">) where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb8-11" title="11">{</a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="dt">var</span> enumerators = input</a>
<a class="sourceLine" id="cb8-13" title="13">        .<span class="fu">Select</span>(x =&gt; x.<span class="fu">GetChildren</span>().<span class="fu">GetEnumerator</span>())</a>
<a class="sourceLine" id="cb8-14" title="14">        .<span class="fu">ToArray</span>();</a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="kw">while</span> (enumerators.<span class="fu">All</span>(e =&gt; e.<span class="fu">MoveNext</span>()))</a>
<a class="sourceLine" id="cb8-17" title="17">    {</a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="kw">yield</span> <span class="kw">return</span> <span class="fu">zipFunc</span>(</a>
<a class="sourceLine" id="cb8-19" title="19">            enumerators.<span class="fu">Select</span>(e =&gt; e.<span class="fu">Current</span>).<span class="fu">ToArray</span>()</a>
<a class="sourceLine" id="cb8-20" title="20">        );</a>
<a class="sourceLine" id="cb8-21" title="21">    }</a>
<a class="sourceLine" id="cb8-22" title="22">}</a></code></pre></div>
<p>Sadly, the invariant that <code>zipFunc</code> receives the same number of <code>T</code>s as were passed to <code>ZipFold</code> is not expressible in C#‚Äôs type system. So as a consumer of <code>ZipFold</code>, you just have to trust that <code>zipFunc</code>‚Äôs argument is of a certain size. In the <code>Equal</code> example, that size is two, because we‚Äôre consuming two trees:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">public</span> <span class="kw">static</span> <span class="dt">bool</span> <span class="fu">Equal</span>(JqlNode j1, JqlNode j2)</a>
<a class="sourceLine" id="cb9-2" title="2">    =&gt; <span class="kw">new</span>[] { j1, j2 }.<span class="fu">ZipFold</span>&lt;JqlNode, <span class="dt">bool</span>&gt;(</a>
<a class="sourceLine" id="cb9-3" title="3">        (ns, childrenEqual) =&gt;</a>
<a class="sourceLine" id="cb9-4" title="4">        {</a>
<a class="sourceLine" id="cb9-5" title="5">            <span class="kw">switch</span> (ns[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb9-6" title="6">            {</a>
<a class="sourceLine" id="cb9-7" title="7">                <span class="kw">case</span> SalaryNode s1 when ns[<span class="dv">1</span>] <span class="kw">is</span> SalaryNode s2:</a>
<a class="sourceLine" id="cb9-8" title="8">                    <span class="kw">return</span> s1.<span class="fu">Currency</span> == s2.<span class="fu">Currency</span></a>
<a class="sourceLine" id="cb9-9" title="9">                        &amp;&amp; s1.<span class="fu">Amount</span> == s2.<span class="fu">Amount</span>;</a>
<a class="sourceLine" id="cb9-10" title="10">                <span class="kw">case</span> TagNode t1 when ns[<span class="dv">1</span>] <span class="kw">is</span> TagNode t2:</a>
<a class="sourceLine" id="cb9-11" title="11">                    <span class="kw">return</span> t1.<span class="fu">Tag</span> == t2.<span class="fu">Tag</span>;</a>
<a class="sourceLine" id="cb9-12" title="12">                <span class="kw">case</span> AndNode a1 when ns[<span class="dv">1</span>] <span class="kw">is</span> AndNode a2:</a>
<a class="sourceLine" id="cb9-13" title="13">                <span class="kw">case</span> OrNode o1 when ns[<span class="dv">1</span>] <span class="kw">is</span> OrNode o2:</a>
<a class="sourceLine" id="cb9-14" title="14">                <span class="kw">case</span> NotNode n1 when ns[<span class="dv">1</span>] <span class="kw">is</span> NotNode n2:</a>
<a class="sourceLine" id="cb9-15" title="15">                    <span class="kw">return</span> childrenEqual.<span class="fu">All</span>(c =&gt; c);</a>
<a class="sourceLine" id="cb9-16" title="16">                <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb9-17" title="17">                    <span class="kw">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb9-18" title="18">            }</a>
<a class="sourceLine" id="cb9-19" title="19">        }</a>
<a class="sourceLine" id="cb9-20" title="20">    );</a></code></pre></div>
<p>Here‚Äôs the Haskell transliteration of this <em>n</em>-ary zip-fold function, which <code>traverse</code>s in the <code>ZipList</code> <code>Applicative</code> to concisely zip <em>n</em> lists of children:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">fermo ::</span> <span class="dt">Plated</span> a <span class="ot">=&gt;</span> ([a] <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-2" title="2">fermo f xs <span class="fu">=</span> f xs (</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="fu">map</span> (fermo f) <span class="fu">$</span> getZipList <span class="fu">$</span> <span class="fu">traverse</span> (<span class="dt">ZipList</span> <span class="fu">.</span> toListOf plate) xs</a>
<a class="sourceLine" id="cb10-4" title="4">    )</a></code></pre></div>
<p><code>ZipFold</code> is available in <a href="https://www.nuget.org/packages/Sawmill/">version 1.3.0 of Sawmill</a>.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on January 10, 2018</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2018-01-10-zip-folding/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Functor Functors</title>
    <link href="http://www.benjamin.pizza/posts/2017-12-15-functor-functors.html" />
    <id>http://www.benjamin.pizza/posts/2017-12-15-functor-functors.html</id>
    <published>2017-12-15T00:00:00Z</published>
    <updated>2017-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December 15, 2017
    
</div>

<p>You can teach a new dog old tricks.</p>
<p>One of the fun things about category theory is that once you‚Äôve learned an idea in one context it‚Äôs easy to apply it to another one. Of the numerous categories available to Haskell programmers, <strong>Hask</strong>, the category of Haskell types and functions, gets the lion‚Äôs share of the attention. Working with standard abstractions in more overlooked categories is a great way to reuse ideas: it makes you look clever, like you‚Äôve invented something new, but actually all you‚Äôve done is put the building blocks together differently. I won‚Äôt tell if you don‚Äôt.</p>
<h2 id="templates-reusable-records">Templates: Reusable Records</h2>
<p>Every now and then I‚Äôll see a question on Stack Overflow or Reddit in which a programmer is trying to work with a bunch of record types which share a similar structure. For a contrived example, in a shopping system you may want to differentiate between completed checkout forms, which are ready to be dispatched, and ‚Äúdraft‚Äù checkout forms, which the user is currently filling in. The simplest way to do this is to build separate types, and write a function to upgrade a draft form to a regular form if all of its fields are filled in.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">CardType</span> <span class="fu">=</span> <span class="dt">Visa</span> <span class="fu">|</span> <span class="dt">AmEx</span> <span class="fu">|</span> <span class="dt">Mastercard</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">data</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">Form</span> {</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">    form_email ::</span> <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">    form_cardType ::</span> <span class="dt">CardType</span>,</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">    form_cardNumber ::</span> <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="ot">    form_cardExpiry ::</span> <span class="dt">Day</span></a>
<a class="sourceLine" id="cb1-8" title="8">}</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">data</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">DraftForm</span> {</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="ot">    draftForm_email ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb1-12" title="12"><span class="ot">    draftForm_cardType ::</span> <span class="dt">Maybe</span> <span class="dt">CardType</span>,</a>
<a class="sourceLine" id="cb1-13" title="13"><span class="ot">    draftForm_cardNumber ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb1-14" title="14"><span class="ot">    draftForm_cardExpiry ::</span> <span class="dt">Maybe</span> <span class="dt">Day</span></a>
<a class="sourceLine" id="cb1-15" title="15">}</a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="ot">toForm ::</span> <span class="dt">DraftForm</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Form</span></a>
<a class="sourceLine" id="cb1-18" title="18">toForm (<span class="dt">DraftForm</span></a>
<a class="sourceLine" id="cb1-19" title="19">    (<span class="dt">Just</span> email)</a>
<a class="sourceLine" id="cb1-20" title="20">    (<span class="dt">Just</span> cardType)</a>
<a class="sourceLine" id="cb1-21" title="21">    (<span class="dt">Just</span> cardNumber)</a>
<a class="sourceLine" id="cb1-22" title="22">    (<span class="dt">Just</span> cardExpiry)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb1-23" title="23">        <span class="dt">Form</span> email cardType cardNumber cardExpiry</a>
<a class="sourceLine" id="cb1-24" title="24">toForm _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Now, the standard trick to de-duplicate these two types is to derive both from what I‚Äôll call a <em>template</em> type, wrapping each field of the template in some type constructor <code>f</code>. You recover <code>Form</code> by setting <code>f</code> to the boring <code>Identity</code> functor, and you get <code>DraftForm</code> by setting <code>f</code> to <code>Maybe</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">FormTemplate</span> f <span class="fu">=</span> <span class="dt">FormTemplate</span> {</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">    _email ::</span> f <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">    _cardType ::</span> f <span class="dt">CardType</span>,</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">    _cardNumber ::</span> f <span class="dt">Text</span>,</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ot">    _cardExpiry ::</span> f <span class="dt">Day</span></a>
<a class="sourceLine" id="cb2-6" title="6">}</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">type</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">type</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="dt">Maybe</span></a></code></pre></div>
<p>So a template is a record type parameterised by a type constructor. It‚Äôll generally have a kind of <code>(* -&gt; *) -&gt; *</code>. The fields of the record are the type constructor applied to a variety of different type arguments. Working with a template typically involves coming up with an interesting type constructor <code>(* -&gt; *)</code> and plugging it in to get interestingly-typed fields. You can think of a record as a container of <code>f</code>s.</p>
<p>This trick has become Haskell folklore - I couldn‚Äôt tell you where I first saw it - but I‚Äôve only seen a few people talk about what happens when you treat templates as first class citizens. To get used to this style, a simple example is giving names to specific instantiations of arbitrary templates:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">Record</span> t <span class="fu">=</span> t <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">type</span> <span class="dt">Partial</span> t <span class="fu">=</span> t <span class="dt">Maybe</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">type</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">Record</span> <span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">type</span> <span class="dt">DraftForm</span> <span class="fu">=</span> <span class="dt">Partial</span> <span class="dt">FormTemplate</span></a></code></pre></div>
<p>The rest of this blog post is about treating template types intuitively as fixed-size containers of functors. I‚Äôll be taking familiar tools for working with containers of <em>values</em> - <code>Functor</code>, <code>Traversable</code>, <code>Representable</code> - and applying them to the context of containers of <em>functors</em>.</p>
<h2 id="functors-from-the-category-of-endofunctors">Functors from the Category of Endofunctors</h2>
<p>In Haskell, categories are represented as a <em>kind</em> <code>k</code> of objects and a <em>type constructor</em> <code>c :: k -&gt; k -&gt; *</code> of morphisms between those objects. If the category <code>C</code> has objects in <code>k1</code> and morphisms in <code>c</code>, and <code>D</code> has objects in <code>k2</code> and morphisms in <code>d</code>, then a functor from <code>C</code> to <code>D</code> is a type constructor <code>f :: k1 -&gt; k2</code> mapping objects paired with an operation <code>fmap :: c a b -&gt; d (f a) (f b)</code> mapping the morphisms. The standard <code>Functor</code> class is for <em>endofunctors on <strong>Hask</strong></em> - the special case in which <code>k1 ~ k2 ~ *</code> and <code>c ~ d ~ (-&gt;)</code>.</p>
<p><img src="/images/2017-12-15-functor-functors/hask.jpg" alt="Endofunctors on Hask" width="900" /></p>
<p>Given two categories <code>C</code> and <code>D</code>, you can construct the category of functors between <code>C</code> and <code>D</code>, written as <code>[C, D]</code>. Objects in this category are functors from <code>C</code> to <code>D</code>, and morphisms are natural transformations between those functors. Since <code>[C, D]</code> is a regular category, you can of course have functors mapping that category to other categories. So in Haskell that‚Äôd be a type of kind <code>(k1 -&gt; k2) -&gt; k3</code>. I‚Äôll call such types <em>functor functors</em>.</p>
<p>We‚Äôre talking about record templates of kind <code>(* -&gt; *) -&gt; *</code>. This fits the pattern of a functor from the functor category, with <code>k1 ~ k2 ~ k3 ~ *</code>. So the functor category in question is the category of endofunctors on <strong>Hask</strong> (that is, members of the standard <code>Functor</code> class), and the destination category is <strong>Hask</strong>. So it‚Äôs reasonable to expect record templates to be functorial in their argument:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="co">-- natural transformations between functors f and g</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">type</span> f <span class="fu">~&gt;</span> g <span class="fu">=</span> <span class="kw">forall</span> x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">-- &quot;functor functors&quot;, functors from the functor category</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">class</span> <span class="dt">FFunctor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ot">    ffmap ::</span> (<span class="dt">Functor</span> g, <span class="dt">Functor</span> h) <span class="ot">=&gt;</span> (g <span class="fu">~&gt;</span> h) <span class="ot">-&gt;</span> f g <span class="ot">-&gt;</span> f h</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">instance</span> <span class="dt">FFunctor</span> <span class="dt">FormTemplate</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-9" title="9">    ffmap eta (<span class="dt">FormTemplate</span> email cardType cardNumber cardExpiry)</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="fu">=</span> <span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb4-11" title="11">            (eta email)</a>
<a class="sourceLine" id="cb4-12" title="12">            (eta cardType)</a>
<a class="sourceLine" id="cb4-13" title="13">            (eta cardNumber)</a>
<a class="sourceLine" id="cb4-14" title="14">            (eta cardExpiry)</a></code></pre></div>
<p><code>FFunctor</code> comes with the usual functor laws. The only difference is the types.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- identity</span></a>
<a class="sourceLine" id="cb5-2" title="2">ffmap <span class="fu">id</span> <span class="fu">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">-- composition</span></a>
<a class="sourceLine" id="cb5-5" title="5">ffmap (eta <span class="fu">.</span> phi) <span class="fu">=</span> ffmap eta <span class="fu">.</span> ffmap phi</a></code></pre></div>
<p><img src="/images/2017-12-15-functor-functors/ffunctor.jpg" alt="Functor functors" width="900" /></p>
<p><code>ffmap</code> encodes the notion of generalising the functor a template has been instantiated with. If you can embed the functor <code>f</code> into <code>g</code>, then you can map a record of <code>f</code>s to a record of <code>g</code>s by embedding each <code>f</code>. (This is also sometimes called ‚Äúhoisting‚Äù.) For example, the boring <code>Identity</code> functor can be embedded into an arbitrary <code>Applicative</code> by injecting the contained value using <code>pure</code>. We can use this to turn a total record into a partial one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">generalise ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb6-2" title="2">generalise (<span class="dt">Identity</span> x) <span class="fu">=</span> <span class="fu">pure</span> x</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">toPartial ::</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Partial</span> t</a>
<a class="sourceLine" id="cb6-5" title="5">toPartial <span class="fu">=</span> ffmap generalise</a></code></pre></div>
<h2 id="traversing-records">Traversing Records</h2>
<p>Now that we have a new dog, it‚Äôs natural to ask which old tricks we can teach it. With the intuition that a template <code>t f</code> is like a container of <code>f</code>s, what does it mean to traverse such a container? <code>sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)</code> takes a container of strategies to produce values and sequences them to get a strategy to produce a container of values. Replacing <em>value</em> with <em>functor</em> in the above sentence, it‚Äôs clear that we need to decide on a notion of ‚Äústrategy to produce a functor‚Äù. <a href="https://stackoverflow.com/questions/44187945/what-should-a-higher-order-traversable-class-look-like">With thanks to Li-yao Xia</a>, the simplest of such notions is a regular applicative functor <code>a</code> returning a functorial value <code>g x</code> - that is, <code>Compose a g</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FTraversable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    ftraverse ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Applicative</span> a)</a>
<a class="sourceLine" id="cb7-3" title="3">              <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> <span class="dt">Compose</span> a g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> a (t g)</a>
<a class="sourceLine" id="cb7-4" title="4">    ftraverse eta <span class="fu">=</span> fsequence <span class="fu">.</span> ffmap eta</a>
<a class="sourceLine" id="cb7-5" title="5"><span class="ot">    fsequence ::</span> (<span class="dt">Functor</span> f, <span class="dt">Applicative</span> a)</a>
<a class="sourceLine" id="cb7-6" title="6">              <span class="ot">=&gt;</span> t (<span class="dt">Compose</span> a f) <span class="ot">-&gt;</span> a (t f)</a>
<a class="sourceLine" id="cb7-7" title="7">    fsequence <span class="fu">=</span> ftraverse <span class="fu">id</span></a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="ot">ffmapDefault ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">FTraversable</span> t)</a>
<a class="sourceLine" id="cb7-10" title="10">             <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g</a>
<a class="sourceLine" id="cb7-11" title="11">ffmapDefault eta <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-12" title="12">    runIdentity <span class="fu">.</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">.</span> eta)</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">fsequence&#39; ::</span> (<span class="dt">FTraversable</span> t, <span class="dt">Applicative</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a (<span class="dt">Record</span> t)</a>
<a class="sourceLine" id="cb7-15" title="15">fsequence&#39; <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="fu">fmap</span> <span class="dt">Identity</span>)</a></code></pre></div>
<p>The <code>FTraversable</code> laws come about by adjusting the <code>Traversable</code> laws to add some <code>Compose</code>-bookkeeping.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- naturality</span></a>
<a class="sourceLine" id="cb8-2" title="2">nu <span class="fu">.</span> ftraverse eta <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> nu <span class="fu">.</span> getCompose <span class="fu">.</span> eta)</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">-- for any applicative transformation nu</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">-- identity</span></a>
<a class="sourceLine" id="cb8-6" title="6">ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Identity</span>) <span class="fu">=</span> <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">-- composition</span></a>
<a class="sourceLine" id="cb8-9" title="9">ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Compose</span> <span class="fu">.</span> <span class="fu">fmap</span> (getCompose<span class="fu">.</span>phi) <span class="fu">.</span> getCompose <span class="fu">.</span> eta)</a>
<a class="sourceLine" id="cb8-10" title="10">    <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">.</span> <span class="fu">fmap</span> (ftraverse phi) <span class="fu">.</span> ftraverse eta</a></code></pre></div>
<p>Implementations of <code>traverse</code> look like implementations of <code>fmap</code> but in an applicative context. Likewise, implementations of <code>ftraverse</code> look like implementations of <code>ffmap</code> in an applicative context, with a few <code>getCompose</code>s scattered around.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">instance</span> <span class="dt">FTraversable</span> <span class="dt">FormTemplate</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2">    ftraverse eta (<span class="dt">FormTemplate</span> email cardType cardNumber cardExpiry)</a>
<a class="sourceLine" id="cb9-3" title="3">        <span class="fu">=</span> <span class="dt">FormTemplate</span> <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb9-4" title="4">            (getCompose <span class="fu">$</span> eta email) <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb9-5" title="5">            (getCompose <span class="fu">$</span> eta cardType) <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb9-6" title="6">            (getCompose <span class="fu">$</span> eta cardNumber) <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb9-7" title="7">            (getCompose <span class="fu">$</span> eta cardExpiry)</a></code></pre></div>
<p>This is where things start to get interesting. The <code>toForm</code> function, which converts a draft form to a regular form if all of its fields have been filled in, can be defined tersely in terms of <code>ftraverse</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">toRecord ::</span> <span class="dt">FTraversable</span> t <span class="ot">=&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Record</span> t)</a>
<a class="sourceLine" id="cb10-2" title="2">toRecord <span class="fu">=</span> ftraverse (<span class="dt">Compose</span> <span class="fu">.</span> <span class="fu">fmap</span> <span class="dt">Identity</span>)</a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ot">toForm ::</span> <span class="dt">DraftForm</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Form</span></a>
<a class="sourceLine" id="cb10-5" title="5">toForm <span class="fu">=</span> toRecord</a></code></pre></div>
<p>Here‚Äôs another example: a generic program, defined by analogy to <code>Foldable</code>‚Äôs <code>foldMap</code>, to collapse the fields of a record into a monoidal value. Note that <code>f () -&gt; m</code> is isomorphic to, but simpler than, <code>forall x. f x -&gt; m</code>. Annoyingly, we have to give a type signature to <code>mkConst</code> to resolve the ambiguity over <code>g</code> in the call to <code>ftraverse</code>. I‚Äôm picking <code>Empty</code> as a way of demonstrating that I have nothing up my sleeves.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">data</span> <span class="dt">Empty</span> a <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">ffoldMap ::</span> <span class="kw">forall</span> f t m<span class="fu">.</span> (<span class="dt">Monoid</span> m, <span class="dt">Functor</span> f, <span class="dt">FTraversable</span> t)</a>
<a class="sourceLine" id="cb11-4" title="4">         <span class="ot">=&gt;</span> (f () <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb11-5" title="5">ffoldMap f <span class="fu">=</span> getConst <span class="fu">.</span> ftraverse mkConst</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="co">-- using ScopedTypeVariables to bind f</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="ot">        mkConst ::</span> f x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Const</span> m) <span class="dt">Empty</span> x</a>
<a class="sourceLine" id="cb11-9" title="9">        mkConst <span class="fu">=</span> <span class="dt">Compose</span> <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> f <span class="fu">.</span> (<span class="fu">$&gt;</span> ())</a></code></pre></div>
<h2 id="zipping-templates">Zipping templates</h2>
<p>Given a pair of records of the same shape <code>t</code>, we should be able to combine them point-wise, matching up the fields of each: <code>fzip :: t f -&gt; t g -&gt; t (Product f g)</code>. In <strong>Hask</strong>, ‚Äúcombining point-wise‚Äù is exactly what the ‚Äúreader‚Äù applicative <code>(-&gt;) r</code> does, so any functor which enjoys an isomorphism to <code>(-&gt;) r</code> for some <code>r</code> has at least a zippy <code>Applicative</code> instance. Such functors are called <em>representable functors</em> and they are members of the class <a href="https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html#t:Representable"><code>Representable</code></a>.</p>
<p>Of course, we‚Äôre working with functors from the functor category, so the relevant notion of <code>Representable</code> will need a little adjustment. Instead of an isomorphism to a function <code>(-&gt;) r</code> we‚Äôll use an isomorphism to a natural transformation <code>(~&gt;) r</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FRepresentable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">type</span> <span class="dt">FRep</span><span class="ot"> t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="ot">    ftabulate ::</span> (<span class="dt">FRep</span> t <span class="fu">~&gt;</span> f) <span class="ot">-&gt;</span> t f</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="ot">    findex ::</span> t f <span class="ot">-&gt;</span> <span class="dt">FRep</span> t a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="ot">fzipWith ::</span> <span class="dt">FRepresentable</span> t</a>
<a class="sourceLine" id="cb12-7" title="7">         <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x <span class="ot">-&gt;</span> h x)</a>
<a class="sourceLine" id="cb12-8" title="8">         <span class="ot">-&gt;</span>            t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t h</a>
<a class="sourceLine" id="cb12-9" title="9">fzipWith f t u <span class="fu">=</span> ftabulate <span class="fu">$</span> \r <span class="ot">-&gt;</span> f (findex t r) (findex u r)</a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="ot">fzipWith3 ::</span> <span class="dt">FRepresentable</span> t</a>
<a class="sourceLine" id="cb12-12" title="12">          <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f x <span class="ot">-&gt;</span> g x <span class="ot">-&gt;</span> h x <span class="ot">-&gt;</span> k x)</a>
<a class="sourceLine" id="cb12-13" title="13">          <span class="ot">-&gt;</span>            t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t h <span class="ot">-&gt;</span> t k</a>
<a class="sourceLine" id="cb12-14" title="14">fzipWith3 f t u v <span class="fu">=</span> ftabulate <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-15" title="15">    \r <span class="ot">-&gt;</span> f (findex t r) (findex u r) (findex v r)</a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="ot">fzip ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> t f <span class="ot">-&gt;</span> t g <span class="ot">-&gt;</span> t (<span class="dt">Product</span> f g)</a>
<a class="sourceLine" id="cb12-18" title="18">fzip <span class="fu">=</span> fzipWith <span class="dt">Pair</span></a></code></pre></div>
<p>The laws for <code>FRepresentable</code> simply state that <code>ftabulate</code> and <code>findex</code> must witness an isomorphism:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="co">-- isomorphism</span></a>
<a class="sourceLine" id="cb13-2" title="2">ftabulate <span class="fu">.</span> findex <span class="fu">=</span> findex <span class="fu">.</span> ftabulate <span class="fu">=</span> <span class="fu">id</span></a></code></pre></div>
<p><code>FRep</code> will typically be a GADT: it tells you what type of value one should expect to find at a given position in a record.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">data</span> <span class="dt">FormTemplateRep</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="dt">Email</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="dt">CardType</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">CardType</span></a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="dt">CardNumber</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="dt">CardExpiry</span><span class="ot"> ::</span> <span class="dt">FormTemplateRep</span> <span class="dt">Day</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="kw">instance</span> <span class="dt">FRepresentable</span> <span class="dt">FormTemplate</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="kw">type</span> <span class="dt">FRep</span> <span class="dt">FormTemplate</span> <span class="fu">=</span> <span class="dt">FormTemplateRep</span></a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10">    ftabulate eta <span class="fu">=</span> <span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb14-11" title="11">        (eta <span class="dt">Email</span>)</a>
<a class="sourceLine" id="cb14-12" title="12">        (eta <span class="dt">CardType</span>)</a>
<a class="sourceLine" id="cb14-13" title="13">        (eta <span class="dt">CardNumber</span>)</a>
<a class="sourceLine" id="cb14-14" title="14">        (eta <span class="dt">CardExpiry</span>)</a>
<a class="sourceLine" id="cb14-15" title="15">    </a>
<a class="sourceLine" id="cb14-16" title="16">    findex p <span class="dt">Email</span> <span class="fu">=</span> _email p</a>
<a class="sourceLine" id="cb14-17" title="17">    findex p <span class="dt">CardType</span> <span class="fu">=</span> _cardType p</a>
<a class="sourceLine" id="cb14-18" title="18">    findex p <span class="dt">CardNumber</span> <span class="fu">=</span> _cardNumber p</a>
<a class="sourceLine" id="cb14-19" title="19">    findex p <span class="dt">CardExpiry</span> <span class="fu">=</span> _cardExpiry p</a></code></pre></div>
<p>Something useful you can do with this infrastructure: filling in defaults for missing values of a partial record. Or, looking at it the other way, overriding certain parts of a record.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">with ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t</a>
<a class="sourceLine" id="cb15-2" title="2">with <span class="fu">=</span> fzipWith override</a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">where</span> override x <span class="dt">Nothing</span> <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb15-4" title="4">          override _ (<span class="dt">Just</span> y) <span class="fu">=</span> <span class="dt">Identity</span> y</a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="ot">fillInDefaults ::</span> <span class="dt">FRepresentable</span> t <span class="ot">=&gt;</span> <span class="dt">Partial</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t <span class="ot">-&gt;</span> <span class="dt">Record</span> t</a>
<a class="sourceLine" id="cb15-7" title="7">fillInDefaults t defaults <span class="fu">=</span> defaults <span class="ot">`with`</span> t</a></code></pre></div>
<p>You can also make a record of <code>Monoid</code> values into a <code>Monoid</code>, once again by zipping.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">newtype</span> <span class="dt">Wrap</span> t f <span class="fu">=</span> <span class="dt">Wrap</span> {<span class="ot"> unWrap ::</span> t f }</a>
<a class="sourceLine" id="cb16-2" title="2">makeWrapped &#39;<span class="dt">&#39;Wrap</span>  <span class="co">-- from Control.Lens.Wrapped</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">instance</span> (<span class="dt">FRepresentable</span> t, <span class="dt">Monoid</span> c) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Wrap</span> t (<span class="dt">Const</span> c)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">Wrap</span> <span class="fu">$</span> ftabulate (<span class="fu">const</span> (<span class="dt">Const</span> <span class="fu">mempty</span>))</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="dt">Wrap</span> t <span class="ot">`mappend`</span> <span class="dt">Wrap</span> u <span class="fu">=</span> <span class="dt">Wrap</span> <span class="fu">$</span> fzipWith <span class="fu">mappend</span> t u</a></code></pre></div>
<h2 id="lenses">Lenses</h2>
<p>Rather than come up with a new notion of <code>Lens</code> formulated in terms of <code>FFunctor</code>, we can reuse the standard <code>Lens</code> type as long as we‚Äôre careful about how polymorphic lenses should be. Specifically, a lens into a record template should express no opinion as to which functor the template should be instantiated with.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">newtype</span> <span class="dt">FLens</span> t a <span class="fu">=</span> <span class="dt">FLens</span> (<span class="kw">forall</span> f<span class="fu">.</span> <span class="dt">Lens&#39;</span> (t f) (f a))</a></code></pre></div>
<p>We can store a template‚Äôs lenses in an instance of the template itself!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">type</span> <span class="dt">Lenses</span> t <span class="fu">=</span> t (<span class="dt">FLens</span> t)</a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="kw">class</span> <span class="dt">HasLenses</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="ot">    lenses ::</span> <span class="dt">Lenses</span> t</a>
<a class="sourceLine" id="cb18-5" title="5"></a>
<a class="sourceLine" id="cb18-6" title="6">makeLenses &#39;<span class="dt">&#39;FormTemplate</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="kw">instance</span> <span class="dt">HasLenses</span> <span class="dt">FormTemplate</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-8" title="8">    lenses <span class="fu">=</span> <span class="dt">FormTemplate</span> {</a>
<a class="sourceLine" id="cb18-9" title="9">        _email <span class="fu">=</span> <span class="dt">FLens</span> email,</a>
<a class="sourceLine" id="cb18-10" title="10">        _cardType <span class="fu">=</span> <span class="dt">FLens</span> cardType,</a>
<a class="sourceLine" id="cb18-11" title="11">        _cardNumber <span class="fu">=</span> <span class="dt">FLens</span> cardNumber,</a>
<a class="sourceLine" id="cb18-12" title="12">        _cardExpiry <span class="fu">=</span> <span class="dt">FLens</span> cardExpiry</a>
<a class="sourceLine" id="cb18-13" title="13">    }</a></code></pre></div>
<h2 id="compositional-validation">Compositional Validation</h2>
<p>Now for an extended example: form validation. We‚Äôll be making use of all of the tools from above - zipping, traversing, and mapping - to design a typed API for validating individual fields of a form.</p>
<p><code>Either</code> isn‚Äôt a great choice for a validation monad, because <code>Either</code> aborts the computation at the first failure. You typically want to report all the errors in a form. Instead, we‚Äôll be working with the following type, which is isomorphic to <code>Either</code> but with an <code>Applicative</code> instance which returns <em>all</em> of the failures in a given computation, combining the values using a <code>Monoid</code>. So it‚Äôs kind of a Frankensteinian mishmash of the <code>Either</code> and <code>Writer</code> applicatives.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">data</span> <span class="dt">Validation</span> e a <span class="fu">=</span> <span class="dt">Failure</span> e <span class="fu">|</span> <span class="dt">Success</span> a <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Validation</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" title="4">    bimap f g (<span class="dt">Failure</span> e) <span class="fu">=</span> <span class="dt">Failure</span> (f e)</a>
<a class="sourceLine" id="cb19-5" title="5">    bimap f g (<span class="dt">Success</span> x) <span class="fu">=</span> <span class="dt">Success</span> (g x)</a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Validation</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="fu">pure</span> <span class="fu">=</span> <span class="dt">Success</span></a>
<a class="sourceLine" id="cb19-9" title="9">    <span class="dt">Success</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Success</span> x <span class="fu">=</span> <span class="dt">Success</span> (f x)</a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="dt">Failure</span> e1 <span class="fu">&lt;*&gt;</span> <span class="dt">Failure</span> e2 <span class="fu">=</span> <span class="dt">Failure</span> (e1 <span class="ot">`mappend`</span> e2)</a>
<a class="sourceLine" id="cb19-11" title="11">    <span class="dt">Failure</span> e1 <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Failure</span> e1</a>
<a class="sourceLine" id="cb19-12" title="12">    _ <span class="fu">&lt;*&gt;</span> <span class="dt">Failure</span> e2 <span class="fu">=</span> <span class="dt">Failure</span> e2</a></code></pre></div>
<p>This <code>Applicative</code> instance has no compatible <code>Monad</code> instance.</p>
<p>We‚Äôll build a library for validation processes which examine a single field of a record at a time. A validation rule for a field typed <code>a</code> is a function which takes an <code>a</code> and returns a <code>Validation e a</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">newtype</span> <span class="dt">Validator</span> e a <span class="fu">=</span> <span class="dt">Validator</span> {<span class="ot"> runValidator ::</span> a <span class="ot">-&gt;</span> <span class="dt">Validation</span> e a }</a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="co">-- a validator which always succeeds</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="ot">noop ::</span> <span class="dt">Validator</span> e a</a>
<a class="sourceLine" id="cb20-5" title="5">noop <span class="fu">=</span> <span class="dt">Validator</span> <span class="dt">Success</span></a></code></pre></div>
<p>If a given field has multiple validation rules, you can compose them under the assumption that each validator leaves its input unchanged.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">(&amp;&gt;) ::</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Validator</span> e a <span class="ot">-&gt;</span> <span class="dt">Validator</span> e a <span class="ot">-&gt;</span> <span class="dt">Validator</span> e a</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="dt">Validator</span> f <span class="fu">&amp;&gt;</span> <span class="dt">Validator</span> g <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> f x <span class="fu">*&gt;</span> g x</a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="co">-- for example</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="ot">emailValidator ::</span> <span class="dt">Validator</span> [<span class="dt">Text</span>] <span class="dt">Text</span></a>
<a class="sourceLine" id="cb21-6" title="6">emailValidator <span class="fu">=</span> hasAtSymbol <span class="fu">&amp;&gt;</span> hasTopLevelDomain</a>
<a class="sourceLine" id="cb21-7" title="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" title="8">        hasAtSymbol <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \email <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb21-9" title="9">            <span class="kw">if</span> <span class="st">&quot;@&quot;</span> <span class="ot">`isInfixOf`</span> email</a>
<a class="sourceLine" id="cb21-10" title="10">            <span class="kw">then</span> <span class="dt">Success</span> email</a>
<a class="sourceLine" id="cb21-11" title="11">            <span class="kw">else</span> <span class="dt">Failure</span> [<span class="st">&quot;No @ in email&quot;</span>]</a>
<a class="sourceLine" id="cb21-12" title="12">        hasTopLevelDomain <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \email <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-13" title="13">            <span class="kw">if</span> <span class="fu">any</span> (<span class="ot">`isSuffixOf`</span> email) topLevelDomains</a>
<a class="sourceLine" id="cb21-14" title="14">            <span class="kw">then</span> <span class="dt">Success</span> email</a>
<a class="sourceLine" id="cb21-15" title="15">            <span class="kw">else</span> <span class="dt">Failure</span> [<span class="st">&quot;Invalid TLD&quot;</span>]</a>
<a class="sourceLine" id="cb21-16" title="16">        topLevelDomains <span class="fu">=</span> [<span class="st">&quot;.com&quot;</span>, <span class="st">&quot;.org&quot;</span>, <span class="st">&quot;.co.uk&quot;</span>]  <span class="co">-- etc</span></a></code></pre></div>
<p>The plan is to store these <code>Validator</code>s in a record template, zip them along an instance of the record itself, and then traverse the result to get either a validated record or a collection of errors. To make things interesting, we‚Äôll store the validation results for a given field in the matching field of another record.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">type</span> <span class="dt">Validators</span> e t <span class="fu">=</span> t (<span class="dt">Validator</span> e)</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">type</span> <span class="dt">Errors</span> e t <span class="fu">=</span> t (<span class="dt">Const</span> e)</a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="co">-- turn a record of validators into a validator of records</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="ot">validate ::</span> (<span class="dt">HasLenses</span> t, <span class="dt">FTraversable</span> t, <span class="dt">FRepresentable</span> t, <span class="dt">Monoid</span> e)</a>
<a class="sourceLine" id="cb22-6" title="6">         <span class="ot">=&gt;</span> <span class="dt">Validators</span> e t</a>
<a class="sourceLine" id="cb22-7" title="7">         <span class="ot">-&gt;</span> <span class="dt">Validator</span> (<span class="dt">Errors</span> e t) (<span class="dt">Record</span> t)</a>
<a class="sourceLine" id="cb22-8" title="8">validate validators <span class="fu">=</span> <span class="dt">Validator</span> <span class="fu">$</span> \record <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-9" title="9">    first unWrap <span class="fu">$</span></a>
<a class="sourceLine" id="cb22-10" title="10">    fsequence&#39; <span class="fu">$</span></a>
<a class="sourceLine" id="cb22-11" title="11">    fzipWith3 applyValidator lenses validators record</a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-13" title="13">        applyValidator</a>
<a class="sourceLine" id="cb22-14" title="14">            (<span class="dt">FLens</span> lens)</a>
<a class="sourceLine" id="cb22-15" title="15">            (<span class="dt">Validator</span> validator)</a>
<a class="sourceLine" id="cb22-16" title="16">            (<span class="dt">Identity</span> value) <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-17" title="17">                <span class="kw">let</span> setError e <span class="fu">=</span> <span class="fu">mempty</span> <span class="fu">&amp;</span> _Wrapped&#39;<span class="fu">.</span>lens<span class="fu">.</span>_Wrapped&#39; <span class="fu">.~</span> e</a>
<a class="sourceLine" id="cb22-18" title="18">                <span class="kw">in</span> first setError <span class="fu">$</span> validator value</a></code></pre></div>
<p><code>applyValidator</code> takes a lens into a record field, a validator for that field and the value in that field. It applies the validator to the value; upon failure it stores the error message (<code>e</code>) in the correct field of the <code>Errors</code> record using the lens. <code>fzipWith3</code> handles the logic of running <code>applyValidator</code> for each field of the record, then <code>fsequence'</code> combines the resulting <code>Validation</code> applicative actions into a single one. So all of the errors from all of the fields are eventually collected into the matching fields of the <code>Errors</code> record and combined monoidally.</p>
<p>A quick test, wherein I test validation on the email field:</p>
<pre><code>ghci&gt; let formValidator = validate
    $ FormTemplate emailValidator noop noop noop
ghci&gt; let today = read &quot;2017-08-17&quot; :: Day

ghci&gt; let form1 = FormTemplate
    (Identity &quot;bhodgson@stackoverflow.com&quot;)
    (Identity Visa)
    (Identity &quot;1234567890123456&quot;)
    (Identity today)
ghci&gt; runValidator formValidator form1
Success (FormTemplate {
    _email = Identity &quot;bhodgson@stackoverflow.com&quot;,
    _cardType = Identity Visa,
    _cardNumber = Identity &quot;1234567890123456&quot;,
    _cardExpiry = Identity 2017-08-17
    })

ghci&gt; let form2 = FormTemplate
    (Identity &quot;notanemail&quot;)
    (Identity Visa)
    (Identity &quot;1234567890123456&quot;)
    (Identity today)
ghci&gt; runValidator formValidator form2
Failure (FormTemplate {
    _email = Const [&quot;No @ in email&quot;,&quot;Invalid TLD&quot;],
    _cardType = Const [],
    _cardNumber = Const [],
    _cardExpiry = Const []
    })</code></pre>
<h2 id="code-review">Code review</h2>
<p>So we have a categorical framework for working with records and templates. Other things fit into this framework, more or less neatly:</p>
<ul>
<li>Monad transformers are often functorial in their <code>m</code> argument.</li>
<li><code>Fix f</code> (a ‚Äúlist of <code>f</code>s‚Äù, if you will) is also a functor functor, where <code>ffmap</code>ping represents a change of variables.</li>
<li>Since the <code>Const</code>, <code>Sum</code>, <code>Product</code> and <code>Compose</code> type combinators are poly-kinded, they can be reused as functor functors too.</li>
<li>Add another primitive <code>FFunctor</code> to apply a functor to a type, <code>newtype At a f = At { getAt :: f a }</code>, and you have a kit to build polynomial functor functors with which you can build templates and write generic programs.</li>
</ul>
<p>One design decision I made when developing the <code>FFunctor</code> class was to give <code>ffmap</code> a <code>(Functor f, Functor g)</code> constraint, so you can only <code>ffmap</code> between types that are in fact functors. This is mathematically principled in some sense, but it has certain engineering tradeoffs compared to an unconstrained type for <code>ffmap</code>. It enables more instances of <code>FFunctor</code> - for example, you can only write <code>Fix</code>‚Äôs <code>ffmap</code> with a <code>Functor</code> constraint for either the input or output type parameters - but it rules out certain usages of <code>ffmap</code>. You can‚Äôt <code>ffmap</code> over a template containing <code>Validator</code>s, for example, because <code>Validator</code> is not a <code>Functor</code>. I <em>didn‚Äôt</em> put the same <code>Functor</code> constraints into <code>FRepresentable</code>‚Äôs methods. An <code>FRep</code> type typically won‚Äôt be functorial - it‚Äôll be GADT-like - so adding a <code>Functor (FRep t)</code> constraint would be far too restrictive.</p>
<p>You‚Äôll notice that the concept of an applicative functor functor is conspicuously absent from my presentation above. <code>FApplicative</code> would probably look something like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">newtype</span> (f <span class="fu">:-&gt;</span> g) a <span class="fu">=</span> <span class="dt">Morph</span> {<span class="ot"> getMorph ::</span> f a <span class="ot">-&gt;</span> g a }</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="kw">class</span> <span class="dt">FFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">FApplicative</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="ot">    fpure ::</span> (<span class="kw">forall</span> a<span class="fu">.</span> f a) <span class="ot">-&gt;</span> t f</a>
<a class="sourceLine" id="cb24-5" title="5"><span class="ot">    fap ::</span> t (f <span class="fu">:-&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g</a>
<a class="sourceLine" id="cb24-6" title="6"></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="ot">fliftA ::</span> <span class="dt">FApplicative</span> t <span class="ot">=&gt;</span> (f <span class="fu">~&gt;</span> g) <span class="ot">-&gt;</span> t f <span class="ot">-&gt;</span> t g</a>
<a class="sourceLine" id="cb24-8" title="8">fliftA eta t <span class="fu">=</span> fpure (<span class="dt">Morph</span> eta) <span class="ot">`fap`</span> t</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="kw">instance</span> <span class="dt">FApplicative</span> <span class="dt">FormTemplate</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-11" title="11">    fpure x <span class="fu">=</span> <span class="dt">FormTemplate</span> x x x x</a>
<a class="sourceLine" id="cb24-12" title="12">    fap</a>
<a class="sourceLine" id="cb24-13" title="13">        (<span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb24-14" title="14">            (<span class="dt">Morph</span> f1)</a>
<a class="sourceLine" id="cb24-15" title="15">            (<span class="dt">Morph</span> f2)</a>
<a class="sourceLine" id="cb24-16" title="16">            (<span class="dt">Morph</span> f3)</a>
<a class="sourceLine" id="cb24-17" title="17">            (<span class="dt">Morph</span> f4))</a>
<a class="sourceLine" id="cb24-18" title="18">        (<span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb24-19" title="19">            email</a>
<a class="sourceLine" id="cb24-20" title="20">            cardType</a>
<a class="sourceLine" id="cb24-21" title="21">            cardNumber</a>
<a class="sourceLine" id="cb24-22" title="22">            cardExpiry)</a>
<a class="sourceLine" id="cb24-23" title="23">        <span class="fu">=</span> <span class="dt">FormTemplate</span></a>
<a class="sourceLine" id="cb24-24" title="24">            (f1 email)</a>
<a class="sourceLine" id="cb24-25" title="25">            (f2 cardType)</a>
<a class="sourceLine" id="cb24-26" title="26">            (f3 cardNumber)</a>
<a class="sourceLine" id="cb24-27" title="27">            (f4 cardExpiry)</a></code></pre></div>
<p><code>FApplicative</code> is a more general interface than <code>FRepresentable</code>, in that it supports notions of composition other than zipping. However, that bookkeeping <code>:-&gt;</code> <code>newtype</code> wrapper is inconvenient. With the normal <code>Applicative</code> class you can map an <em>n</em>-ary function over <em>n</em> applicative values directly: <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. With <code>FApplicative</code> you have to apply the <code>Morph</code> constructor as many times as <code>f</code> has arguments: <code>fpure (Morph $ \x -&gt; Morph $ \y -&gt; Morph $ \z -&gt; f x y z) `fap` t `fap` u `fap` v</code>, which becomes very unwieldy very quickly. (<a href="https://www.reddit.com/r/haskell/comments/78xxql/structures_of_arrays_functors_and_continuations/doy80ft/">/u/rampion has come up with nicer syntax for this</a>, but it involves <a href="https://gist.github.com/rampion/20291bde6c8568c11f9cc5923d9639eb#file-ffunctor-hs-L28">a more complicated formulation of <code>FApplicative</code></a>.) On the other hand, <code>FApplicative</code> does open up some interesting options for the design of <code>FTraversable</code>: one can traverse in an <code>FApplicative</code> rather than an <code>Applicative</code>. This gives some nice type signatures - <code>fsequence :: (FTraversable t, FApplicative f) =&gt; t f -&gt; f t</code> - and is strictly more general than the <code>FTraversable</code> I gave above, since any <code>Applicative</code> can be lifted into an <code>FApplicative</code> by composition (<code>newtype ComposeAt a f g = ComposeAt { getComposeAt :: f (g a) }</code>).</p>
<p>How useful are these tools in practice? Would I structure a production application around functor functors? Probably not. It‚Äôs a question of balance - while it‚Äôs useful to recognise functorial structures in categories other than <strong>Hask</strong> as a thinking tool, actually representing such abstractions in code doesn‚Äôt always pay off. Haskell already has a rich ecosystem of tools for working with the <code>Functor</code> family, but there‚Äôs much less code in the wild that‚Äôs structured around functor functors. This is partly because <code>Functor</code> has the advantage of being a standard class in <code>base</code>, but it‚Äôs also because code built around functor functors is a little less convenient to work with, typically requiring some tedious <code>newtype</code> bookkeeping.</p>
<p>Over the course of putting together this article I came across some work by others on this very topic. I‚Äôve spotted versions of these classes being packaged with bigger libraries such as <a href="http://hackage.haskell.org/package/hedgehog-0.5.1/docs/Hedgehog-Internal-HTraversable.html"><code>hedgehog</code></a> and <a href="https://hackage.haskell.org/package/quickcheck-state-machine-0.2.0/docs/Test-StateMachine-Types-HFunctor.html"><code>quickcheck-state-machine</code></a>. There are also a few packages providing similar tools. The most mature of these seems to be <a href="http://hackage.haskell.org/package/rank2classes"><code>rank2classes</code></a>, which includes some Template Haskell tools for deriving instances; there‚Äôs also <a href="http://hackage.haskell.org/package/conkin">the Conkin package</a>, which has <a href="https://github.com/rampion/conkin/blob/master/README.md">a well-written tutorial</a> focusing on working with data in column-major order.</p>
<p>Haskell‚Äôs full of big ideas and powerful programming idioms. In this post we saw an example of reinterpreting some familiar tools - <code>Functor</code>, <code>Traversable</code> and <code>Representable</code> - in a new context. With the intuition that a record template is a container of functors, and the formalism of functors from the functor category, we were able to reuse intuitions about those familiar tools to write terse and generic programs.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on December 15, 2017</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2017-12-15-functor-functors/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Recursion Without Recursion</title>
    <link href="http://www.benjamin.pizza/posts/2017-11-13-recursion-without-recursion.html" />
    <id>http://www.benjamin.pizza/posts/2017-11-13-recursion-without-recursion.html</id>
    <published>2017-11-13T00:00:00Z</published>
    <updated>2017-11-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on November 13, 2017
    
</div>

<p>If you visit <a href="https://www.stackoverflow.com/jobs">Stack Overflow Jobs</a> you‚Äôll see that our job search form supports a simple advanced search syntax, including Boolean operators and a number of custom filters such as technology tags and minimum salary. For example, I hate writing JavaScript, but my loyalties can be bought, so I might type <a href="https://stackoverflow.com/jobs?sort=i&amp;q=%5Bc%23%5D+and+(not+%5Bjavascript%5D+or+salary%3A50000gbp)"><code>[c#] and (not [javascript] or salary:50000gbp)</code></a> into the search box. This advanced search syntax is called JQL, for <em>Jobs Query Language</em>.</p>
<p>It should come as no surprise that our codebase contains a miniature compiler for our miniature query language. Our compiler looks much like any other compiler: there‚Äôs a parser which produces an abstract syntax tree (hereafter <em>AST</em>), a pipeline of analysers and transformations which operate on that AST, and a code generator which turns the JQL into an ElasticSearch query. (Actually, queries that are simple enough end up skipping the Elastic code generation step, instead being used by an interpreter to search an in-memory cache of jobs.)</p>
<p><img src="/images/2017-11-13-recursion-without-recursion/compiler.jpg" alt="Compiler overview" width="900" /></p>
<p>In this post I‚Äôm going to focus on the middle part of that pipeline: how to write operations traversing a tree with a minimum of boilerplate.</p>
<h2 id="asts-and-operations">ASTs and operations</h2>
<p>The JQL AST looks roughly like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">abstract</span> <span class="kw">class</span> JqlNode {}</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">class</span> AndNode : JqlNode</a>
<a class="sourceLine" id="cb1-3" title="3">{</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">public</span> JqlNode Left { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="kw">public</span> JqlNode Right { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-6" title="6">}</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">class</span> OrNode : JqlNode</a>
<a class="sourceLine" id="cb1-8" title="8">{</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">public</span> JqlNode Left { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="kw">public</span> JqlNode Right { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-11" title="11">}</a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">class</span> NotNode : JqlNode</a>
<a class="sourceLine" id="cb1-13" title="13">{</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="kw">public</span> JqlNode Operand { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-15" title="15">}</a>
<a class="sourceLine" id="cb1-16" title="16"><span class="kw">class</span> SalaryNode : JqlNode</a>
<a class="sourceLine" id="cb1-17" title="17">{</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="kw">public</span> <span class="dt">int</span> Amount { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="kw">public</span> <span class="dt">string</span> Currency { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-20" title="20">}</a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">class</span> TagNode : JqlNode</a>
<a class="sourceLine" id="cb1-22" title="22">{</a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="kw">public</span> <span class="dt">string</span> Tag { <span class="kw">get</span>; }</a>
<a class="sourceLine" id="cb1-24" title="24">}</a></code></pre></div>
<p>Each syntactic form in the source language is represented as a subclass of <code>JqlNode</code>. Using the example I gave above, the input string <code>[c#] and (not [javascript] or salary:50000gbp)</code> would be represented as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;c#&quot;</span>),</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb2-4" title="4">        <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>)),</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">    )</a>
<a class="sourceLine" id="cb2-7" title="7">)</a></code></pre></div>
<p><img src="/images/2017-11-13-recursion-without-recursion/ast.jpg" alt="The abstract syntax tree" width="900" /></p>
<p>When you need to analyse a <code>JqlNode</code>, you use pattern matching to see what type of node you have, and recursively query the operands of <code>And</code>/<code>Or</code>/<code>Not</code> nodes. Here‚Äôs a function which searches for the <code>TagNode</code>s in a tree:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb3-1" title="1">IEnumerable&lt;<span class="dt">string</span>&gt; <span class="fu">ExtractTags</span>(JqlNode node)</a>
<a class="sourceLine" id="cb3-2" title="2">{</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">switch</span> (node)</a>
<a class="sourceLine" id="cb3-4" title="4">    {</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="kw">case</span> TagNode t:</a>
<a class="sourceLine" id="cb3-6" title="6">            <span class="kw">return</span> <span class="kw">new</span>[] { t.<span class="fu">Tag</span> };</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="kw">case</span> AndNode a:</a>
<a class="sourceLine" id="cb3-8" title="8">            <span class="co">// recursively extract the tags from the two operands</span></a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="kw">return</span> <span class="fu">ExtractTags</span>(a.<span class="fu">Left</span>).<span class="fu">Concat</span>(<span class="fu">ExtractTags</span>(a.<span class="fu">Right</span>));</a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="kw">case</span> OrNode o:</a>
<a class="sourceLine" id="cb3-11" title="11">            <span class="kw">return</span> <span class="fu">ExtractTags</span>(o.<span class="fu">Left</span>).<span class="fu">Concat</span>(<span class="fu">ExtractTags</span>(o.<span class="fu">Right</span>));</a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="kw">case</span> NotNode n:</a>
<a class="sourceLine" id="cb3-13" title="13">            <span class="kw">return</span> <span class="fu">ExtractTags</span>(n.<span class="fu">Operand</span>);</a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="kw">case</span> SalaryNode s:</a>
<a class="sourceLine" id="cb3-15" title="15">            <span class="kw">return</span> Enumerable.<span class="fu">Empty</span>&lt;<span class="dt">string</span>&gt;();</a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb3-17" title="17">            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentOutOfRangeException</span>(<span class="fu">nameof</span>(node));</a>
<a class="sourceLine" id="cb3-18" title="18">    }</a>
<a class="sourceLine" id="cb3-19" title="19">}</a></code></pre></div>
<p>Transforming a <code>JqlNode</code> to produce a new <code>JqlNode</code> is a similar story: you recursively traverse the tree, taking it apart and putting it back together. Here‚Äôs an example of an optimisation step which never doesn‚Äôt remove double-negatives, so a query like <code>not (not [java])</code> gets simplified to <code>[java]</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb4-1" title="1">JqlNode <span class="fu">SimplifyDoubleNegatives</span>(JqlNode node)</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">switch</span> (node)</a>
<a class="sourceLine" id="cb4-4" title="4">    {</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="kw">case</span> NotNode n1 when n1.<span class="fu">Operand</span> <span class="kw">is</span> NotNode n2:</a>
<a class="sourceLine" id="cb4-6" title="6">            <span class="kw">return</span> <span class="fu">SimplifyDoubleNegatives</span>(n2.<span class="fu">Operand</span>);</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="kw">case</span> TagNode t:</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="kw">return</span> t;</a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="kw">case</span> SalaryNode s:</a>
<a class="sourceLine" id="cb4-10" title="10">            <span class="kw">return</span> s;</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">case</span> AndNode a:</a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="co">// recursively process the operands and rebuild the node</span></a>
<a class="sourceLine" id="cb4-13" title="13">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb4-14" title="14">                <span class="fu">SimplifyDoubleNegatives</span>(a.<span class="fu">Left</span>),</a>
<a class="sourceLine" id="cb4-15" title="15">                <span class="fu">SimplifyDoubleNegatives</span>(a.<span class="fu">Right</span>)</a>
<a class="sourceLine" id="cb4-16" title="16">            );</a>
<a class="sourceLine" id="cb4-17" title="17">        <span class="kw">case</span> OrNode o:</a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb4-19" title="19">                <span class="fu">SimplifyDoubleNegatives</span>(o.<span class="fu">Left</span>),</a>
<a class="sourceLine" id="cb4-20" title="20">                <span class="fu">SimplifyDoubleNegatives</span>(o.<span class="fu">Right</span>)</a>
<a class="sourceLine" id="cb4-21" title="21">            );</a>
<a class="sourceLine" id="cb4-22" title="22">        <span class="kw">case</span> NotNode n:</a>
<a class="sourceLine" id="cb4-23" title="23">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">NotNode</span>(</a>
<a class="sourceLine" id="cb4-24" title="24">                <span class="fu">SimplifyDoubleNegatives</span>(n.<span class="fu">Operand</span>)</a>
<a class="sourceLine" id="cb4-25" title="25">            );</a>
<a class="sourceLine" id="cb4-26" title="26">        <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb4-27" title="27">            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentOutOfRangeException</span>(<span class="fu">nameof</span>(node));</a>
<a class="sourceLine" id="cb4-28" title="28">    }</a>
<a class="sourceLine" id="cb4-29" title="29">}</a></code></pre></div>
<p>This type of code gets pretty tedious pretty quickly! In both of these functions, only one of the <code>case</code>s was interesting (<code>case TagNode t</code> in <code>ExtractTags</code> and <code>case NotNode n1 when n1.Operand is NotNode n2</code> in <code>SimplifyDoubleNegatives</code>); the rest of each function was just boilerplate to recursively operate on nodes‚Äô children. You‚Äôre interested in a particular syntactic pattern, but searching the whole tree for that pattern requires more code than finding the pattern does. In the real JQL compiler we have about a dozen subclasses of <code>JqlNode</code>, so around 90% of the code in each operation is boilerplate!</p>
<h2 id="easier-querying">Easier Querying</h2>
<p>Here‚Äôs the first insight that‚Äôll help us improve on this situation. In <code>ExtractTags</code> we were searching the tree for nodes satisfying a particular pattern. But supposing you had a list of every possible subtree - the root node, all of its children, all of their children, and so on - you could use LINQ to query that list to find nodes satisfying the pattern you‚Äôre looking for. We‚Äôll call the function which extracts the list of subtrees <code>SelfAndDescendants</code>.</p>
<p>Given a tree like the example from above (<code>[c#] and (not [javascript] or salary:50000gbp)</code>), <code>SelfAndDescendants</code> will yield every subtree in a depth-first, left-to-right manner:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">new</span> JqlNode[]</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;c#&quot;</span>),</a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb5-6" title="6">            <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>)),</a>
<a class="sourceLine" id="cb5-7" title="7">            <span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>)</a>
<a class="sourceLine" id="cb5-8" title="8">        )</a>
<a class="sourceLine" id="cb5-9" title="9">    ),</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;c#&quot;</span>),</a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>)),</a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>)</a>
<a class="sourceLine" id="cb5-14" title="14">    ),</a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>)),</a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>),</a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>)</a>
<a class="sourceLine" id="cb5-18" title="18">}</a></code></pre></div>
<p>Here‚Äôs <code>SelfAndDescendants</code> in use:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb6-1" title="1">IEnumerable&lt;<span class="dt">string</span>&gt; <span class="fu">ExtractTags</span>(JqlNode node)</a>
<a class="sourceLine" id="cb6-2" title="2">    =&gt; node</a>
<a class="sourceLine" id="cb6-3" title="3">        .<span class="fu">SelfAndDescendants</span>()</a>
<a class="sourceLine" id="cb6-4" title="4">        .<span class="fu">OfType</span>&lt;TagNode&gt;()</a>
<a class="sourceLine" id="cb6-5" title="5">        .<span class="fu">Select</span>(n =&gt; n.<span class="fu">Tag</span>);</a></code></pre></div>
<p>What an improvement! This code is much shorter, but more importantly it‚Äôs clearer and more direct. You can directly read off the intention of the code, rather than having to decipher the pattern of recursive calls. It‚Äôs also harder to get wrong - I personally am rather prone to forgetting to make a recursive call when I‚Äôm writing these sorts of functions. What‚Äôs more, <code>SelfAndDescendants</code> is totally reusable. If you can write a LINQ query, you can get whatever information you need from a <code>JqlNode</code>.</p>
<p>Of course, the pattern-matching and recursion has to go somewhere, and that somewhere is the reusable <code>SelfAndDescendants</code> function.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">public</span> <span class="kw">static</span> IEnumerable&lt;JqlNode&gt; <span class="fu">SelfAndDescendants</span>(<span class="kw">this</span> JqlNode node)</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">yield</span> <span class="kw">return</span> node;</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">switch</span> (node)</a>
<a class="sourceLine" id="cb7-5" title="5">    {</a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="kw">case</span> TagNode t:</a>
<a class="sourceLine" id="cb7-7" title="7">            <span class="kw">yield</span> <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="kw">case</span> SalaryNode s:</a>
<a class="sourceLine" id="cb7-9" title="9">            <span class="kw">yield</span> <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="kw">case</span> AndNode a:</a>
<a class="sourceLine" id="cb7-11" title="11">            <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(a.<span class="fu">Left</span>))</a>
<a class="sourceLine" id="cb7-12" title="12">                <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb7-13" title="13">            <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(a.<span class="fu">Right</span>))</a>
<a class="sourceLine" id="cb7-14" title="14">                <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="kw">case</span> OrNode o:</a>
<a class="sourceLine" id="cb7-16" title="16">            <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(o.<span class="fu">Left</span>))</a>
<a class="sourceLine" id="cb7-17" title="17">                <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb7-18" title="18">            <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(o.<span class="fu">Right</span>))</a>
<a class="sourceLine" id="cb7-19" title="19">                <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb7-20" title="20">        <span class="kw">case</span> NotNode n:</a>
<a class="sourceLine" id="cb7-21" title="21">            <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(n.<span class="fu">Operand</span>))</a>
<a class="sourceLine" id="cb7-22" title="22">                <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb7-23" title="23">        <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb7-24" title="24">            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentOutOfRangeException</span>(<span class="fu">nameof</span>(node));</a>
<a class="sourceLine" id="cb7-25" title="25">    }</a>
<a class="sourceLine" id="cb7-26" title="26">}</a></code></pre></div>
<p>Google crawls links between pages for you, so you can search the Web for a specific piece of information; <code>SelfAndDescendants</code> crawls pointers between nodes for you, so you can search a tree for a specific piece of information. Programming tree traversals by hand is like manually clicking every link on the Web!</p>
<h2 id="a-reusable-transformer">A Reusable Transformer</h2>
<p>How about transforming a JQL AST? <code>SimplifyDoubleNegatives</code> searches a JQL tree for a pattern and rebuilds a new version of the tree. Can this be extracted into a reusable function?</p>
<p>To rewrite a tree, you search the tree for nodes satisfying the pattern you‚Äôre looking for and replace them. As with <code>SelfAndDescendants</code>, the trick is to separate the responsibilities of <em>looking at every node in the tree</em> and <em>deciding whether to replace a given node</em>. You can write a higher-order function - let‚Äôs call it <code>Rewrite</code> - which applies a <code>Func</code> to every node in a JQL tree from bottom to top; then it‚Äôs the <code>Func</code>‚Äôs job to decide what to do with each node.</p>
<p>For example, <code>Rewrite</code> will take the query above (<code>[c#] and (not [javascript] or salary:50000gbp)</code>) and a function <code>transformer</code>, and compute the expression:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;c#&quot;</span>)),</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">NotNode</span>(</a>
<a class="sourceLine" id="cb8-5" title="5">            <span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">TagNode</span>(<span class="st">&quot;javascript&quot;</span>))</a>
<a class="sourceLine" id="cb8-6" title="6">        )),</a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="fu">transformer</span>(<span class="kw">new</span> <span class="fu">SalaryNode</span>(<span class="dv">50000</span>, <span class="st">&quot;gbp&quot;</span>))</a>
<a class="sourceLine" id="cb8-8" title="8">    ))</a>
<a class="sourceLine" id="cb8-9" title="9">))</a></code></pre></div>
<p>So <code>transformer</code> gets applied to every subtree exactly once. <code>Rewrite</code> is a mapping operation, like LINQ‚Äôs <code>Select</code>. Here‚Äôs how it‚Äôs implemented.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">static</span> JqlNode <span class="fu">Rewrite</span>(</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">this</span> JqlNode node,</a>
<a class="sourceLine" id="cb9-3" title="3">    Func&lt;JqlNode, JqlNode&gt; transformer</a>
<a class="sourceLine" id="cb9-4" title="4">)</a>
<a class="sourceLine" id="cb9-5" title="5">{</a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="kw">switch</span> (node)</a>
<a class="sourceLine" id="cb9-7" title="7">    {</a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="kw">case</span> TagNode t:</a>
<a class="sourceLine" id="cb9-9" title="9">            <span class="kw">return</span> <span class="fu">transformer</span>(t);</a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="kw">case</span> SalaryNode s:</a>
<a class="sourceLine" id="cb9-11" title="11">            <span class="kw">return</span> <span class="fu">transformer</span>(s);</a>
<a class="sourceLine" id="cb9-12" title="12">        <span class="kw">case</span> AndNode a:</a>
<a class="sourceLine" id="cb9-13" title="13">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb9-14" title="14">                <span class="fu">transformer</span>(a.<span class="fu">Left</span>),</a>
<a class="sourceLine" id="cb9-15" title="15">                <span class="fu">transformer</span>(a.<span class="fu">Right</span>)</a>
<a class="sourceLine" id="cb9-16" title="16">            );</a>
<a class="sourceLine" id="cb9-17" title="17">        <span class="kw">case</span> OrNode o:</a>
<a class="sourceLine" id="cb9-18" title="18">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb9-19" title="19">                <span class="fu">transformer</span>(o.<span class="fu">Left</span>),</a>
<a class="sourceLine" id="cb9-20" title="20">                <span class="fu">transformer</span>(o.<span class="fu">Right</span>)</a>
<a class="sourceLine" id="cb9-21" title="21">            );</a>
<a class="sourceLine" id="cb9-22" title="22">        <span class="kw">case</span> NotNode n:</a>
<a class="sourceLine" id="cb9-23" title="23">            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">NotNode</span>(<span class="fu">transformer</span>(n.<span class="fu">Operand</span>));</a>
<a class="sourceLine" id="cb9-24" title="24">        <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb9-25" title="25">            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ArgumentOutOfRangeException</span>(<span class="fu">nameof</span>(node));</a>
<a class="sourceLine" id="cb9-26" title="26">    }</a>
<a class="sourceLine" id="cb9-27" title="27">}</a></code></pre></div>
<p>To use this <code>Rewrite</code> method, you write a transformation function which calculates a replacement for each node. If there‚Äôs no replacing to do, it just returns the same node. Like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb10-1" title="1">JqlNode <span class="fu">SimplifyDoubleNegatives</span>(JqlNode node)</a>
<a class="sourceLine" id="cb10-2" title="2">    =&gt; node.<span class="fu">Rewrite</span>(</a>
<a class="sourceLine" id="cb10-3" title="3">        n =&gt; n <span class="kw">is</span> NotNode n1 &amp;&amp; n1.<span class="fu">Operand</span> <span class="kw">is</span> NotNode n2</a>
<a class="sourceLine" id="cb10-4" title="4">            ? n2.<span class="fu">Operand</span></a>
<a class="sourceLine" id="cb10-5" title="5">            : n</a>
<a class="sourceLine" id="cb10-6" title="6">    );</a></code></pre></div>
<p>Once again, this code is a huge improvement over the verbose version which used <code>switch</code> and recursion. <code>Rewrite</code> allows us to get straight to the point and only think about the parts of the tree we‚Äôre interested in.</p>
<h2 id="from-pattern-to-library">From Pattern to Library</h2>
<p><code>Rewrite</code> and <code>SelfAndDescendants</code> wrap up two particular types of recursion, for reuse in a wide variety of operations. This is a powerful way to program - gone are the days of writing a bespoke traversal for every operation! - and these two functions form the basis of most of the operations in the production JQL compiler, but in this form they don‚Äôt constitute a library. <code>SelfAndDescendants</code> and <code>Rewrite</code>, as written above, have knowledge of <code>JqlNode</code> baked in to them; you have to hand-write equivalent functions to work on your own datatypes.</p>
<p>We can turn this design into something generic, though, by abstracting over tree-shaped structures. What do we mean when we say a datatype is tree-shaped? The distinguishing feature which makes a tree a tree, unlike any other datatype, is recursion: each node in a tree has <em>children</em> which are also nodes.</p>
<p><img src="/images/2017-11-13-recursion-without-recursion/children.jpg" alt="Nodes and their children" width="900" /></p>
<p>As the picture shows, you can reach every node in a tree just by looking at each node‚Äôs children. If you can show me how to replace your children, I can replace your children‚Äôs children and so on. So let‚Äôs use an interface to model the notion of an object with a collection of children.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">interface</span> IRewritable&lt;T&gt; where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb11-2" title="2">{</a>
<a class="sourceLine" id="cb11-3" title="3">    IEnumerable&lt;T&gt; <span class="fu">GetChildren</span>();</a>
<a class="sourceLine" id="cb11-4" title="4">    T <span class="fu">SetChildren</span>(IEnumerable&lt;T&gt; newChildren);</a>
<a class="sourceLine" id="cb11-5" title="5">}</a></code></pre></div>
<p>A type <code>T</code> is <em>rewritable</em> if it knows how to access its immediate children - in other words, if you can get and set an <code>IEnumerable&lt;T&gt;</code> representing a node‚Äôs children. We‚Äôre working with immutable trees, remember, so <code>SetChildren</code> doesn‚Äôt modify the current instance - it returns a new <code>T</code> the same as the current instance but with different children. Part of the contract of <code>IRewritable</code> is that you shouldn‚Äôt call <code>SetChildren</code> with a different number of children to what you got from <code>GetChildren</code>. For example, an <code>And</code> node always has two children, so you shouldn‚Äôt try to call <code>SetChildren</code> with only one child (because, how would the <code>And</code> node rebuild itself?).</p>
<p>Now we can package up those <code>Rewrite</code> and <code>SelfAndDescendants</code> functions for any rewritable object, once and for all. If you show me how to reach each node‚Äôs immediate children, I can recursively apply that recipe to look at the children‚Äôs children and so on.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">static</span> IEnumerable&lt;T&gt; SelfAndDescendants&lt;T&gt;(<span class="kw">this</span> T node)</a>
<a class="sourceLine" id="cb12-2" title="2">    where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb12-3" title="3">{</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="kw">yield</span> <span class="kw">return</span> node;</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="kw">foreach</span> (<span class="dt">var</span> child <span class="kw">in</span> node.<span class="fu">GetChildren</span>())</a>
<a class="sourceLine" id="cb12-6" title="6">        <span class="kw">foreach</span> (<span class="dt">var</span> descendant <span class="kw">in</span> <span class="fu">SelfAndDescendants</span>(child))</a>
<a class="sourceLine" id="cb12-7" title="7">            <span class="kw">yield</span> <span class="kw">return</span> descendant;</a>
<a class="sourceLine" id="cb12-8" title="8">}</a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">static</span> T Rewrite&lt;T&gt;(<span class="kw">this</span> T node, Func&lt;T, T&gt; transformer)</a>
<a class="sourceLine" id="cb12-10" title="10">    where T : IRewritable&lt;T&gt;</a>
<a class="sourceLine" id="cb12-11" title="11">{</a>
<a class="sourceLine" id="cb12-12" title="12">    <span class="dt">var</span> children = node.<span class="fu">GetChildren</span>();</a>
<a class="sourceLine" id="cb12-13" title="13">    <span class="dt">var</span> newChildren = children.<span class="fu">Select</span>(c =&gt; c.<span class="fu">Rewrite</span>(transformer)).<span class="fu">ToList</span>();</a>
<a class="sourceLine" id="cb12-14" title="14">    <span class="dt">var</span> nodeWithNewChildren = node.<span class="fu">SetChildren</span>(newChildren);</a>
<a class="sourceLine" id="cb12-15" title="15">    <span class="kw">return</span> <span class="fu">transformer</span>(nodeWithNewChildren);</a>
<a class="sourceLine" id="cb12-16" title="16">}</a></code></pre></div>
<p>You typically implement <code>IRewritable</code> abstractly on the base type, using overrides on each subclass to find the children.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">abstract</span> <span class="kw">class</span> JqlNode : IRewritable&lt;JqlNode&gt;</a>
<a class="sourceLine" id="cb13-2" title="2">{</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">public</span> <span class="kw">abstract</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>();</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="kw">public</span> <span class="kw">abstract</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren);</a>
<a class="sourceLine" id="cb13-5" title="5">}</a>
<a class="sourceLine" id="cb13-6" title="6"><span class="kw">class</span> AndNode : JqlNode</a>
<a class="sourceLine" id="cb13-7" title="7">{</a>
<a class="sourceLine" id="cb13-8" title="8">    <span class="co">// fields as before</span></a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="kw">public</span> <span class="kw">override</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb13-10" title="10">        =&gt; <span class="kw">new</span>[] { Left, Right };</a>
<a class="sourceLine" id="cb13-11" title="11">    <span class="kw">public</span> <span class="kw">override</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren)</a>
<a class="sourceLine" id="cb13-12" title="12">        =&gt; <span class="kw">new</span> <span class="fu">AndNode</span>(</a>
<a class="sourceLine" id="cb13-13" title="13">            newChildren.<span class="fu">ElementAt</span>(<span class="dv">0</span>), </a>
<a class="sourceLine" id="cb13-14" title="14">            newChildren.<span class="fu">ElementAt</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-15" title="15">        );</a>
<a class="sourceLine" id="cb13-16" title="16">}</a>
<a class="sourceLine" id="cb13-17" title="17"><span class="kw">class</span> OrNode : JqlNode</a>
<a class="sourceLine" id="cb13-18" title="18">{</a>
<a class="sourceLine" id="cb13-19" title="19">    <span class="kw">public</span> <span class="kw">override</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb13-20" title="20">        =&gt; <span class="kw">new</span>[] { Left, Right };</a>
<a class="sourceLine" id="cb13-21" title="21">    <span class="kw">public</span> <span class="kw">override</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren)</a>
<a class="sourceLine" id="cb13-22" title="22">        =&gt; <span class="kw">new</span> <span class="fu">OrNode</span>(</a>
<a class="sourceLine" id="cb13-23" title="23">            newChildren.<span class="fu">ElementAt</span>(<span class="dv">0</span>), </a>
<a class="sourceLine" id="cb13-24" title="24">            newChildren.<span class="fu">ElementAt</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-25" title="25">        );</a>
<a class="sourceLine" id="cb13-26" title="26">}</a>
<a class="sourceLine" id="cb13-27" title="27"><span class="kw">class</span> NotNode : JqlNode</a>
<a class="sourceLine" id="cb13-28" title="28">{</a>
<a class="sourceLine" id="cb13-29" title="29">    <span class="kw">public</span> <span class="kw">override</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb13-30" title="30">        =&gt; <span class="kw">new</span>[] { Operand };</a>
<a class="sourceLine" id="cb13-31" title="31">    <span class="kw">public</span> <span class="kw">override</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren)</a>
<a class="sourceLine" id="cb13-32" title="32">        =&gt; <span class="kw">new</span> <span class="fu">NotNode</span>(newChildren.<span class="fu">Single</span>());</a>
<a class="sourceLine" id="cb13-33" title="33">}</a>
<a class="sourceLine" id="cb13-34" title="34"><span class="kw">class</span> SalaryNode : JqlNode</a>
<a class="sourceLine" id="cb13-35" title="35">{</a>
<a class="sourceLine" id="cb13-36" title="36">    <span class="kw">public</span> <span class="kw">override</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb13-37" title="37">        =&gt; Enumerable.<span class="fu">Empty</span>&lt;JqlNode&gt;();</a>
<a class="sourceLine" id="cb13-38" title="38">    <span class="kw">public</span> <span class="kw">override</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren)</a>
<a class="sourceLine" id="cb13-39" title="39">        =&gt; <span class="kw">this</span>;</a>
<a class="sourceLine" id="cb13-40" title="40">}</a>
<a class="sourceLine" id="cb13-41" title="41"><span class="kw">class</span> TagNode : JqlNode</a>
<a class="sourceLine" id="cb13-42" title="42">{</a>
<a class="sourceLine" id="cb13-43" title="43">    <span class="kw">public</span> <span class="kw">override</span> IEnumerable&lt;JqlNode&gt; <span class="fu">GetChildren</span>()</a>
<a class="sourceLine" id="cb13-44" title="44">        =&gt; Enumerable.<span class="fu">Empty</span>&lt;JqlNode&gt;();</a>
<a class="sourceLine" id="cb13-45" title="45">    <span class="kw">public</span> <span class="kw">override</span> JqlNode <span class="fu">SetChildren</span>(IEnumerable&lt;JqlNode&gt; newChildren)</a>
<a class="sourceLine" id="cb13-46" title="46">        =&gt; <span class="kw">this</span>;</a>
<a class="sourceLine" id="cb13-47" title="47">}</a></code></pre></div>
<p>Note that there isn‚Äôt a single line of recursion in the JQL-specific code. It‚Äôs all wrapped up in the <code>SelfAndDescendants</code> and <code>Rewrite</code> functions, which are totally generic and reusable for any type of tree.</p>
<p>The old-fashioned way of writing reusable tree traversals is the Visitor pattern: you put the recursive traversal code in a base class, with virtual methods for each type of node that can be overridden to carry out specific operations. (This is how the Roslyn API works, for example.) <code>IRewritable</code> is a clear improvement over the Visitor pattern. Being designed around base classes and overriding, the Visitor pattern is far clunkier to use than the functional API I outlined above; and <code>IRewritable</code> allows operations like <code>Rewrite</code> can be written totally generically, whereas with the Visitor pattern every type of tree has its own Visitor base class.</p>
<h2 id="sawmill">Sawmill</h2>
<p>I‚Äôve named this generic tree-processing library Sawmill - because it‚Äôs all about taking trees apart! - and it‚Äôs available on <a href="https://www.nuget.org/packages/Sawmill">NuGet</a> and <a href="https://github.com/benjamin-hodgson/Sawmill">GitHub</a>. I‚Äôll outline some improvements on the design I demonstrated above, which you‚Äôll find in Sawmill.</p>
<p>First, what I find remarkable about this design is its power-to-weight ratio. <code>IRewritable</code> is a very simple interface with an easily-grasped meaning, but you can build a load of rich, generic tools on top of it. Sawmill contains versions of <code>SelfAndDescendants</code> and <code>Rewrite</code>, but also a bunch of other extension methods at varying levels of nicheness, all getting squeezed through the <code>IRewritable</code> interface:</p>
<ul>
<li>A family of versions of <code>SelfAndDescendants</code> capturing a variety of traversal orders (preorder, postorder and breadth-first), in both eager and lazy form</li>
<li>A <code>Fold</code> method for reducing a whole tree to a value, like LINQ‚Äôs <code>Aggregate</code></li>
<li>An iterative version of <code>Rewrite</code> which rewrites an expression repeatedly until it reaches a normal form</li>
<li>Functions for replacing one node at a time</li>
<li>A method to get an efficient mutable view of a node and its neighbours, which supports complex sequences of edits to a localised part of a tree</li>
<li>Tools to help you implement <code>IRewriter</code>, either using a typed fluent interface or using reflection and code generation.</li>
<li>Some minor API changes to the outline above, to enable greater efficiency for certain common cases.</li>
</ul>
<p>I‚Äôve also had success implementing <code>IRewritable</code> for a variety of tree-like types. Sawmill comes bundled with versions of all of these extension methods for some well-known tree types - <code>Expression</code>, <code>XmlNode</code>, and <code>XElement</code> - and I‚Äôve written extension packages which do the same for <code>Newtonsoft.Json.Linq</code> and Roslyn‚Äôs syntax trees. (These implementations actually use a separate <code>IRewriter</code> interface, because of course I can‚Äôt add a new interface to the above types.) Realising that I could use Sawmill to layer a simple, uniform API on top of preexisting objects felt like a real validation of the design.</p>
<p>Sawmill‚Äôs version of <code>Rewrite</code> also makes an important optimisation which I glossed over above: parts of the tree which the <code>transformer</code> function didn‚Äôt change are <em>shared</em> between the new and old versions of the tree. If you change a single node, you only have to rebuild that node‚Äôs ancestors (because their children have changed), not the parts of the tree you didn‚Äôt touch.</p>
<p><img src="/images/2017-11-13-recursion-without-recursion/sharing.jpg" alt="The sharing optimisation" width="900" /></p>
<p>(This is safe for immutable trees like those in Roslyn; for mutable trees like <code>XmlNode</code> the whole tree has to be copied if any part of it changes. This makes me sad - in my view those types should have been immutable all along.)</p>
<p>Finally and most importantly, I want to acknowledge Neil Mitchell‚Äôs great work in his <a href="https://hackage.haskell.org/package/uniplate"><code>uniplate</code> Haskell library</a> (and <a href="https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html">its modernised port in <code>lens</code></a>), upon which Sawmill is based. I wouldn‚Äôt even have thought of this C# library if I hadn‚Äôt already encountered it in Haskell. It‚Äôs weird to think that <a href="http://ndmitchell.com/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf"><code>uniplate</code>‚Äôs accompanying article</a> was published in 2007! Someone - my mum, if you must know - once told me that in the field of medicine it takes a decade for new research to reach mainstream practice. I think that process might take even longer in computer science, but I hope that in writing this I‚Äôve helped these ideas along a little.</p>

<section class="comments">
    <h1>Comments</h1>

    <ol class="comments-list">
        
            <li class="comment">
    
        <h2 class="comment-header">By <a href="http://www.benjamin.pizza">Benjamin</a> on November 13, 2017</h2>
    
    <div class="comment-body"><p>To join the discussion, <a href="https://github.com/benjamin-hodgson/benjamin-hodgson.github.io/blob/develop/comments/2017-11-13-recursion-without-recursion/example.md">send me a pull request</a>.</p></div>
</li>
        
    </ol>
</section>
]]></summary>
</entry>

</feed>
